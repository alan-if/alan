<?xml version="1.0"?>
<tasktracker>
<task>
<desc>Alan</desc>
<notes/>
<priority>2</priority>
<origest>405.89</origest>
<currest>404.89</currest>
<elapsed>264.89</elapsed>
<isopen>1</isopen>
<task>
<desc>Increments</desc>
<notes/>
<priority>2</priority>
<origest>67</origest>
<currest>67</currest>
<elapsed>27</elapsed>
<isopen>1</isopen>
<task>
<desc>Increment: version 3.0.dev35</desc>
<notes/>
<priority>2</priority>
<origest>27</origest>
<currest>27</currest>
<elapsed>27</elapsed>
<isopen>1</isopen>
<task>
<desc>Refactor listing so that all termination produces a list with the appropiate format</desc>
<notes>Prompted by SYSERR not producing -cc style listing which trashed alanIDE:s message parsing</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor DIRECTLY to be on WHERE?</desc>
<notes/>
<priority>2</priority>
<origest>3</origest>
<currest>3</currest>
<elapsed>3</elapsed>
<isopen>1</isopen>
<task>
<desc>Aggregates and filters must allow DIRECTLY</desc>
<notes>Currently they are not transitive, but should have the same semantics as IN and AT: DIRECTLY is required to get the non-transitive evaluation</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>DIRECTLY HERE, DIRECTLY NEARBY</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>NEARBY should use non-DIRECTLY version of where()</desc>
<notes>Make test cases for NEARBY first</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>A container without a description should be listed automatically</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document that $n prints using player words and Say does not.</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Restriction analysis questions</desc>
<notes>The current analysis of restrictions and their statements seem to start by assuming every parameter is an instance and go from there. That's ok, but at the same time the legacy indicates that the default of a parameter should be "object", and we can have these at the same time:

Syntax x = x (a) (b)
    Where a Isa c1
        Else "Here b is either an entity or an object, depending on the strategy."

Probably this should work by first working through the restrictions to see if a parameter is restricted, if not at all it should be assumed an "object" and if it was restricted (in the class dimension, not container) it should start out as an entity.

This is not true. The legacy only indicates that the parameter should be an object in the *bodies*. The restrictions could still assume entity to begin with. Ensure that a non-restricted parameter is an object.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow expression in List statement.</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Text Styles</desc>
<notes>New statement "Style xxx." Use GLK styles:
- Normal
- Emphasis
- Preformatted
- Alert
- Quote</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Inherited Exits</desc>
<notes>Usefullness?

Yes, you could allow inherting the complete exit and just override the target location, This could make checks and does clauses inherited.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>-ide switch to output messages with character positions</desc>
<notes>In AlanIDE it would be nice to use character positions instead of line markers.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>INIT clause as property</desc>
<notes>An INIT clause would be very handy to initialize an instance when it is created. This would allow for much greater modularity.

The INITIALIZE clause is executed at the start location and the current actor is hero.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor: Allocate parameter lists</desc>
<notes>If the compiler sends the maximum number of parameters in any syntax (header-&gt;maxParameters) we can allocate only so much space for the parameter manpulation lists in the interpreters parser.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Events as attributes</desc>
<notes>This could be handy for storing the currently executing event in a series of events, see Ferrari example.

Would require expressions in Cancel and Schedule statements.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>PLAY statement</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Resource type management</desc>
<notes>The extensions of resource files (sounds and images) sometimes controls the kind of resource. Case in point: .MOD is MUS and .AIF/.AIFF is SND.

We need a mapping which implies that we need to discover file extensions in resource file names.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Use Blorb-layer for resources</desc>
<notes>Lacking source for a blorb-packer, possibly in iblorb sources...</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add To Every xyz &lt;exits&gt;</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Investigate multi-class word problems</desc>
<notes>Word as synonym and verb
Word as synonym and direction
Word as verb and direction
....

Which of the above works, and what is the problem with each that doesn't?
</notes>
<priority>2</priority>
<origest>4</origest>
<currest>4</currest>
<elapsed>4</elapsed>
<isopen>1</isopen>
<task>
<desc>Word-clash</desc>
<notes>Multiclass word problem 3: PREPOSITION &amp; VERB
Words can't be prepositions and verbs at the same time. See gestx()

New and better dictionary handling in the compiler could remedy the multiple word class problems. Or as a first step, try to find a way to point out where a 333 comes from (e.g. 'e' defined both as a synonym and as a another word class).
</notes>
<priority>2</priority>
<origest>3</origest>
<currest>3</currest>
<elapsed>3</elapsed>
<isopen>1</isopen>
<task>
<desc>Multiclass word problem 1: VERB &amp; DIRECTION</desc>
<notes>Multiclass word problem 1: VERB &amp; DIRECTION
The VERBDIR problem (check regression test verbdir), using the same word as both a verb and a direction does not work.

This does not work since the first word in the player input must indicate which type of command it is.

Document this and make the message an error? Yes.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Multiclass word problem 2: ADJECTIVE &amp; VERB</desc>
<notes>Multiclass word problem2: ADJECTIVE &amp; VERB, doesn't work because the dictionary handling in the compiler (newwrd) returns the code of the found word which is the same as the adjective, resulting in execution of the wrong (if any) verb... (See regression test adjverb) Somehow we must separate word codes from the codes used by the objects, verbs etc.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Multiclass word problem 3: PREPOSITION &amp; VERB</desc>
<notes>Multiclass word problem 3: PREPOSITION &amp; VERB
Words can't be prepositions and verbs at the same time. See gestx()
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Locals should override directions</desc>
<notes>Currently For Each e gives an error message if the direction 'e' is already declared. Directions are not available to the programmer so should not be entered in the symbol table?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Refactor: move descriptionSRCP et.al into a Description Node</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow nearby to be applied to locations</desc>
<notes>See games/goto.

Currently the interpreter crashes.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Implement &lt;what&gt; NEAR &lt;what&gt;</desc>
<notes>As a complement to NEARBY</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Default restrictions in instances inheriting from unknown classes gives 323</desc>
<notes>compiler/testing/defaultRestrictionInUnknownClass.alan</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verify file type association and Windows double click</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.dev36</desc>
<notes/>
<priority>2</priority>
<origest>11</origest>
<currest>11</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
<task>
<desc>Allow class references in attribute declarations of classes</desc>
<notes>E.g.
    Every door
       Has otherside door.
    End Every door.

This would make it possible to avoid "fake" instances and instances that have incorrect values because initialization was forgotten.

Note in the manual that a "fake" instance is a way to solve NULL-pointers, i.e a special marker indicating "no relevant value".

If a class was allowed we could ensure that an actual instance was used by traversing the inheritance tree. An instance should not be allowed to inherit from a class with a non-instance initalization without initializing it (somewhere along the inheritance chain).
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Confirmations</desc>
<notes>E.g. if the player says quit the game should allow the player to change his mind. (Although not if the game quit because of a false move or some such.) E.g 

IF CONFIRM "Are you sure (Y/N) ?" THEN ...

or even

DEPENDING ON CONFIRM "Restore, reStart, Quit or go Back to the game (R/S/Q/B)?"
 =1 : RESTORE.
 =2 : RESTART.
 =3 : QUIT.
END DEPEND.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Should checks only be run for alternatives that match?</desc>
<notes>Currently the checks are run for all alternatives.

Verify what this would mean in a practical example.

I think only checks for matching alternatives would be natural.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document what is built-in</desc>
<notes>Messages
Classes
Instances (hero)
Words
Pronouns</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor and unit test the args &amp; switches functions</desc>
<notes>Refactor out "basename()" and "testprogramname()" or some such</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor: add a context.symbol</desc>
<notes>context.class &amp; context.instance both have symbols which are needed at some places</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Warn if loop variable hides some symbol</desc>
<notes>especially if it refers to a class because that probably indicates the misconception of:

FOR EACH entity DO

but that is not allowed:

FOR EACH instance ISA entity DO
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Default description for a instance should be either in definite or indefinite form.</desc>
<notes>Is there a problem with current defaults:
 - There is a object here.
 - Actor is here.

Would "There is a actor here." be a better default?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>What happens if we don't strip spaces from strings? AKA How to make a map?</desc>
<notes>It is not possible to draw a map in ASCII-art since the compiler strips spaces from strings and replaces them with a single space.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Check up the library wrt. PRONOUNs; introduce human, person, man, woman</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Looping over a string</desc>
<notes>There is little use for strip if you can not loop over a string. Maybe

  For Each (Word|Character) &lt;f&gt; In &lt;string&gt;</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.dev37</desc>
<notes/>
<priority>2</priority>
<origest>15</origest>
<currest>15</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
<task>
<desc>Attribute references without "of" in certain contexts</desc>
<notes>It would be possible to use simple references to an attribute if the context is inside a class or instance. E.g

  The x
     Has y,
     Description Say y.
  End The x.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Consistency for empty property declarations</desc>
<notes>An empty Description signifies a description but an empty one. Possibly this should instead signify a return to the default. An empty should then be Description ""

Check for consistency with other instances of local overides.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Problem with consequtive include's</desc>
<notes>If an file has include-directives directly after each other the return from one, e.g. when the included file does not exist, positions the next DEPRECATED message on the wrong spot.

See compiler/testing/includeFile.alan</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Example: composite object</desc>
<notes>Like a box with a couple of buttons on it.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Think about similarities between the different clauses</desc>
<notes>DESCRIPTION [CHECK DOES]
ENTERED
EXIT [CHECK DOES END]

Any better structure? Optional END for DESCRIPTION, ENTERED etc?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Converter should move global verbs with parameters into a class</desc>
<notes>Which class? Will "thing" do? Probably.

Design:
For each syntax found, if it has parameters save the verb name in list. When encountering a verb with such a name add "Add To Every thing" around it.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow locations in initial location and Locate if IN</desc>
<notes>This would allow collecting locations in heaps.

Better: use IN location to mean the exits?

OR: defer this until arrays are available.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Unify error messages</desc>
<notes>Check error messages and try to unify such as

Multiple VERB '%1'

with

Multiple %1 '%2'</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>MENTIONED can not be inherited</desc>
<notes>Since the MENTIONED is generated automatically from the NAME it can not be inherited. If this was not the case it could be inherited, but then it would be impossible to indicate to override it to use the name instead.

This is kind of a general question, but affects the MENTIONED particularly.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add NEGATIVE ARTICLE/FORM clause</desc>
<notes>with "Say No x." and "$-1" as print forms.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Literal should not inherit from Thing?</desc>
<notes>It should be a separate base class, or should it.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add To Every xyz</desc>
<notes>Investigate what is left to do:


All below is done:
----------------------------
It should be possible to add features to classes:

Add To Every object ...

Otherwise there is no way to do the same thing as V2 ATTRIBUTES.

In v3 it should be possible to add anything that is not already available:

attributes (DONE), scripts, exits, verbs - adds to the list, but can not redefine if already existing

initial location, container - can only be added if it has none

mentioned? article? description?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Warn for DOES preceeded by an unconditional CHECK</desc>
<notes>DONE for verbs

TODO: Descriptions, ?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Obscure error message for aggregate filters without ","</desc>
<notes>"Count Isa object In inventory" (missing comma) parses as:

"Count Isa object" "In inventory"

which is correct but gives the confusing error message:

  *1*   311 E : Must refer to an instance.

pointing to "count" since that is the left hand side of the assumed expression

&lt;something&gt; &lt;where&gt;</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>winarun does not parse its command line</desc>
<notes>E.g.
    winarun images -t
results in
    Could not open "images -t.a3c"</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.alpha1</desc>
<notes/>
<priority>2</priority>
<origest>4</origest>
<currest>4</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
<task>
<desc>Allow Start section at an arbitrary place in the source</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>HAVING clause on aggregate filters</desc>
<notes>It should be possible to filter aggregation over not only &lt;is&gt; &lt;something&gt; but also for numeric attributes, e.g
 HAVING x = 3
 HAVING y &gt; atr OF b</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Inherit Entered</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add Entered</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Version 3.0.alpha2</desc>
<notes/>
<priority>2</priority>
<origest>3</origest>
<currest>3</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
<task>
<desc>Settings dialogue for compiler on Windows</desc>
<notes>Need: we need to be able to give options to the compiler while still double clicking on it.

Design:</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Inherting all props</desc>
<notes>Investigate which ones are left!!!!

DONE:
attributes
scripts
verbs
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Symbolic instance and class references in debugger</desc>
<notes>To do this we must generate the programmer names also, this is the symbol to use.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Version 3.0beta1</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
<task>
<desc>List line numbers for which LINE instructions are generated?</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Version 3.0</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
<task>
<desc>Syntax description in the manual</desc>
<notes>Make sure the grammar syntax is clearly explained</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Version 3.1.dev1</desc>
<notes/>
<priority>2</priority>
<origest>5</origest>
<currest>5</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
<task>
<desc>Scope definitions</desc>
<notes>A suggestion from Greg:

Another thought is that you may want to have more
than one verb sharing a scope definition. So
maybe the scope test could be moved out of the
syntax statement and into a new kind of statement:

   SCOPE topic_scope CONTAINS obj WHERE
     obj IN known_topics.

and then you would say

   SYNTAX ask_about = 'ask' a 'about' t
     WHERE
       t FROM topic_scope
         ELSE "You've never heard of anything like that."
       AND t ISA ConversationTopic
         ELSE "That's not a valid conversation topic."

This would also help to untangle the syntax of
the WHERE clause and make it clear which parts of
it are to do with scope and which parts are to
do with type determination.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
<task>
<desc>Restrictions should allow location tests?</desc>
<notes>But you could have restrictions which tested one 
parameter with a "location test". The semantics would 
be something like:

1) if you use a location test for a parameter as a 
restriction, then you are in complete charge of scoping 
for that parameter
2) if you don't, the interpreter will use the standard 
method
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Disambiguation using checks</desc>
<notes>Example:

There is water in the lake. You are carrying a bottle of water.
&gt; drink water
I don't know which water you mean.

This should be done in parse.c but at the position where we want to do this we don't have enough information to run possible(). Surrounded it by ifdefs DISAMBIGUATE_USING_CHECKS</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Also allow 'can' as attribute header words</desc>
<notes>So that we can do

The gun Isa object
  Can shoot

The girl Isa actor
  Can talk

is_are_has = 'IS' | 'ARE' | 'HAS' | 'CAN'
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>How to handle special dictionary entries in unsupported languages?</desc>
<notes>The word types: ALL, THEM, NOISE, EXCEPT etc. are inserted by the compiler. How can we support it for a language not directly supported?

New clause?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Dynamic creation of instances</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
</task>
<task>
<desc>Pending</desc>
<notes/>
<priority>2</priority>
<origest>91</origest>
<currest>91</currest>
<elapsed>8</elapsed>
<isopen>1</isopen>
<task>
<desc>Override additively inherited properties</desc>
<notes>Names are inherited in an additive way, is there a need for overriding NAMES from the parent? If so is this common to more properties? Which ones are inherited in an additive way?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Which-form and Any-form</desc>
<notes>In some languages the words "which" and "any" has different forms depending on the noun. E.g in german:

"Ich kann hier keinen/keiner/kein $1 sehen."

To fix this we would need two new forms, one for "which" and one for "any".
Possibly we could have the embedded tags:

  $+&lt;n&gt; = definite form
  $0&lt;n&gt; = indefinite form
  $-&lt;n&gt; = none/any form (negative)
  $?&lt;n&gt; = which form (interrogative)
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Potential problem: non-ISO sorting of dictionary</desc>
<notes>So don't sort it. Linear search will be sufficiently fast.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Infinite loops can occur if the articles try to Say The this.</desc>
<notes>There are a number of situations that can cause infinite interpreter loops. Like the recursive describe. Possibly they can be detected in the same way.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Are only CHECKs with corresponding WHEN run?</desc>
<notes>Or should the WHEN only apply to the DOES-part?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Some kind of procedures</desc>
<notes>NEED: to be able to execute common code without mis-using e.g events.

ANALYSIS: we could add a new property, METHOD or ACTION or ... Which could be declared in classes and instances. It would be inherited normally, so you could "Do method Of instance." or "method:instance" or "open:door". In the last case we would probably not have methods in same namespace as verbs.

Still to figure out how to send parameters, and to make analysis of availability of syntax parameters (complicated to investigate all invocations to verify their environment).</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
<task>
<desc>Functions</desc>
<notes>Andrew Duncan Heale &lt;helix@yoyo.cc.monash.edu.au&gt;</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Warn if there is no When clause for every parameter in the syntax</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>VISITS is a reserved word that causes many compiler problems</desc>
<notes>See compiler test case visits.alan</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Mutual exclusive boolean attributes</desc>
<notes>Maybe boolean attributes could be extended so they can
be declared in mutually-exclusive groups:

  hero attributes
    is neuter or male or female. -- defaults to first value, i.e. neuter

then after doing

  make hero male

then 'hero is male' would be true and both 'hero is neuter'
and 'hero is female' would be false.

This would also be useful for open/closed attributes, etc.

  the door isa object
    is open or closed.
    is unlocked or locked.

Greg Ewing, Computer Science Dept, +--------------------------------------+
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor? Allow only WHT_ID?</desc>
<notes>If we use WHT_ID only we can use "object" as the predefined parameter name in default syntax. This makes it impossible to use OBJECT in verbs with defined syntax.

How about WHT_LOC, &amp; WHT_ACT?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor UNDO? and SCORE to be FUNCTION_SYMBOLS</desc>
<notes>Add a FUNCTION_SYMBOL to the symbol table.
Look up all WHAT_ID expressions and transform them into function_expressions with function code instead.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Language texts in external files</desc>
<notes>Need:
To allow user managed language translations.

Design:
If an external file with the name used in the langauge option this should be used as texts for the pre-defined interpreter messages.

Implementation:
1) Allow any id as a value for the language option.
2) Find an external langauge-specific message file and use it.
3) If the language did not have an external message file nor a entry in the pre-complied messages issue an error message.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor: change "newxyz(&amp;srcp, " to just "newxyz(srcp, " for all xyz?</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow 'A' as well as 'An' in Say statement</desc>
<notes>Both 'a' and 'an' should be allowed in Say statement. However 'a' is commonly an identifier? Introducing it as a keyword/id introduces grammar conflicts. Investigate!</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Meta-output should be in []</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>CHECKs on containers</desc>
<notes>Checks on containers to augment limits, e.g if a chest is closed we could put that test in the container check instead of the verb check?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>New execution model</desc>
<notes>If we use addresses as the primary addressing mechanism we could more easily support new attribute reference format.

E.g. 

instance 4   -- push address to instance 4:s admin data
attribute 5 -- lookup its 5-attribute and push its address
instance 3
location  -- get location field
write -- write the top value of the stack to the address beneath

However this does not go well with separated data since that is not adressed by Amachine addresses.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow multiple parameter references in a WHEN clause in a Verb body</desc>
<notes>Why? What is the problem?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>QUIT question &amp; prompt</desc>
<notes>"Restore, reStart or Quit (R/S/Q)?" Preferably it should be possible to automatically deduce the response characters from the format (see item on CONFIRM).

Note also that there should possibly also be a difference between the QUIT statement (to really end the game) and the QUIT player command which should/Could allow restart etc. as per the item about CONFIRMATIONS. (This should probably be done in the library.)</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>A picture file with an unknown extension gets passed through</desc>
<notes>E.g a.jpeg transforms into pic1.jpeg which the glk does not find. Possibly would go away if the blorb-layer was used. Investigate it.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Bug: Syntax typing error</desc>
<notes>
Thomas N:
paramatr() in atr.c
Statements in ELSE-part of a SYNTAX is really typed to the *complement* of the WHERE-part. I.e. the parameters can nearly always be STRINGS and NUMBERS which do not have attributes. This means that it is almost always impossible to refer to attributes in SYNTAX-ELSE clauses.
This must be handled by a new strategy for parameter class analysis. See "Parameter environment classing"

SteveG: 
Secondly, I got an error about using an attribute in a CHECK's ELSE statement that said I couldn't do it because there was no guarantee that the entity wouldn't be a string or container in which case the attribute would not be defined. That error message was quite correct. However when I changed the CHECK to be more specific, I did not get the error message even though the entity might still be a string etc. The attached bad_attr.ala game demonstrates.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Text formatting "statements"</desc>
<notes>
$b for bold? Use ANSI? Or how about:

 $bold$

 $the x$

Or HTML:

this text is &lt;b&gt;bold&lt;/b&gt;

Or XML-ish:

this text is &lt;indent&gt;indented&lt;/indent&gt;</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>BUG: Running WinGlkArun from the prompt with wrong command line shows no message</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Actor conversation</desc>
<notes>A simple first step would be to recognize command format &lt;actor&gt;, &lt;command&gt; and respond with a message indicating that it is not possible to order other actors about.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Separate release &amp; distribution in top level Makefile</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>SYNTAX ELSE parameter analysis</desc>
<notes>
From a mail to SteveG:
The same goes for statements in the ELSE part of the WHERE clause in the SYNTAX declaration, and that is also how it is implemented (except it has some bugs). 
The problem is just that the assumption is false for exactly those statements. It is actually exactly the *complement* of what the types specified in the WHERE clause! 
E.g. in the example above the IF statement will be executed whenever the 'o' is *not* an OBJECT. So you can only allow operations legal for NUMBERS, STRINGS, ACTORS etc, actually everything NOT OBJECT.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow reverse noun/adjective order</desc>
<notes>Need:
To allow latin type of langauges. "molin rouge"

Design:
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Unnatural exit handling in winarun</desc>
<notes>After the game has exited it is not possible to access the menus although they are visible.
A status variable could instead be used to indicate if a game is in progress or not. It should be possible to quit a game and then open another game to play or restart it.
This seems to be a limitation in the way GLK does it. Or rather the way terminate() hands over t glk_exit() after confirmation.
Perhaps this is not a great problem.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Compile command version of interpreter with mingw</desc>
<notes>It is possible if not using TERMIO, but how do we then present status line?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>When executing verbs in current location inherited verbs should be executed also</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>What to do about instances that are neither objects or actors?</desc>
<notes>
Currently they are not described at all.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>CHECKs as disambiguations for multiple objects</desc>
<notes>Could it be possible to use the CHECKs (as in the ALL handling) when disambiguating between multiple objects refered  to in a command (C.f. Lech's TAKE BOX when one is in the inventory and one on the floor).
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>InstanceAndVerb</desc>
<notes>regression/pending/instanceAndVerb.alan

syserr() because 'l' is both an instance and a verb.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Possibility for author to specify content (or lack of) status line</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Tips about debugging in the docs</desc>
<notes>Use Marnie's (?) example of rules executing many times and resetting the script for an actor.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Multiple warnings for redefined verbs</desc>
<notes>Verb x, y, x
...

Verb x
 
Will generate two errors at the second "Verb x" when one would suffice.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document how it all fits together</desc>
<notes>A chapter describing the overall structure of a adventure execution and how that relates to the various Alan elements:

First the player is shown an intro text (this is the start section). Then he sees a room name and a room description (this is the instance of a sub-class of location) etc. etc.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Can't assign to loop variable</desc>
<notes>Check and error message? This is not possible with the current syntax anyway...</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Ability to declare that an attribute is the reversal of another attribute</desc>
<notes>It could be useful to have a way of declaring that things like "open"
and "closed" refer to the same attribute with opposite senses, e.g.

  OBJECT ATTRIBUTES
    IS open ELSE closed.

Then "front_door IS open" and "front_door IS NOT closed" would be
equivalent, as would "MAKE front_door open" and "MAKE front_door not
closed", etc. etc.

Greg Ewing, Computer Science Dept, +--------------------------------------+
University of Canterbury,    | A citizen of NewZealandCorp, a   |
Christchurch, New Zealand    | wholly-owned subsidiary of USA Inc.  |
greg@cosc.canterbury.ac.nz    +--------------------------------------+</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor? Make Props a field in Class and Instance instead of a dynamically allocated node</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document how to produce a SCRIPT-file</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow definition of constants</desc>
<notes>Constant
  NEUTER = 0.
  BOY = 1.
  GIRL = 2.

The hero Isa actor
  sex NEUTER.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Menu entry for debugging (only available when option is turned on)</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Author modifiable prompt</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Warn for non-existing include directories</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Fix picture in about Arun box</desc>
<notes>Only occurs on W2k &amp; XP</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Separate data and code</desc>
<notes>Separate data and code in the .acd into two separate areas, point to them from the header. This way we could more easily do two things: run from disk (if memory is not large enough to hold both data and code) and implement undo (just save the data area before each command)</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow expressions between two strings as SAY</desc>
<notes>
E.g.

 "I have" capacity Of bottle "left."

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Re-implement the "go" handling so that it is no longer a noise</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Restrictions may make erroneous warning for multiply executed verb bodies</desc>
<notes>If a syntax has more than one parameter and one is restricted to classes to which the verb body does not apply, the body will not be executed more than once:

Syntax x = x (p1) (p2) Where p1 Isa literal And p2 Isa object ...

Add To Every object
  Verb x ...</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Unknown words in player input to create strings</desc>
<notes>
Experiment with making unknown words into strings:

&gt; say hello to the guard

would automagically translate to

&gt; say "hello" to the guard

if "hello" is an unknown word. This could possibly be made automatically by the interpreter when encountering an (or a series of ) unknown word. Problem is probably how to error handle.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Parameter environment classing</desc>
<notes>The analysis of every statement should have a list of available parameters and their classes. Using these you can analyse classing even inside IF statements:

IF p ISA object THEN
   -- here we know that p has the class object
ELSE
   -- here p has the same class as before IF
END IF.

Furthermore you can in the IF expression verify that the parameter is a subclass to the class p has before the IF statement.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Unit tests for word-handling</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Alternativ to USE &lt;script&gt; FOR &lt;actor&gt;</desc>
<notes>START &lt;actor&gt; &lt;script&gt;.  E.g.

Start george cleaning.
Start tiger hunting.

(This caused grammar conflicts at three points, since it is impossible to know if to reduce constructs with no 'END' on a 'START' (as if the start section was next) or if to shift it (as if a START &lt;actor&gt; &lt;script&gt; was next)

To fix this better conflict resolutions must be made in the grammar. Conflicts was in MESSAGE, WHERE and WHEN without END WHEN. since they all have lists of statements that are not terminated.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Reference to local attributes without prefixing</desc>
<notes>E.g

The i
  Has a.
...
  Set a To 4.
End The i.


Instead of

Set a Of i To 4.

which seems a bit superflous.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Restricted multiple object references</desc>
<notes>Investigate the possibility to allow:

&gt; TAKE ALL green chairs

This implies 1) a notion of plural nouns (in english generally 's' and 2) new built in multiple reference algorithm. Plurals won't be a problem if replaced by

&gt; TAKE EVERY green chair
&gt; PUSH EVERY button
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>END [THE|EVERY] ID</desc>
<notes>Make it possible to have THE and EVERY optional in END clauses.

But not both THE and the ID...</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Lists of case clauses in DEPENDING ON</desc>
<notes>
Allow lists of right hand expressions in the DEPENDING ON case clauses:

DEPENDING ON x
=1, =3 : ...
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>SCHEDULE &lt;event&gt; &lt;where&gt; WHEN &lt;expr&gt;</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Plural handling</desc>
<notes>What do we need it for again? Possibly "take all balls"

Possibly could be a new clause so objects would have:

DEFINITE
  "the ball"

INDEFINITE
  "a ball"

PLURAL
  "balls"

Compare http://www.firthworks.com/roger/informfaq/oo.html#11</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Background statement</desc>
<notes>
To display a background picture (where appropriate) I like the Zork Zero thing...</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Optional syntax parts</desc>
<notes>SYNTAX
 look_up = 'look' 'up' (str) ['in' (lexikon)]

i.e. optional parts of a syntax which can be given default parameters.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Space bar in &lt;more&gt;</desc>
<notes>Already works in winarun (GLK)</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Listing of saved games</desc>
<notes>Already available in most GLK-versions</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Try UNIX/MingW as target OS for toolmaker</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>All instances not inheriting from anything should inherit directly from entity</desc>
<notes>What is the problem with current strategy?

Document it and make sure abilities are handled correctly. E.g. it should not be described, that is added by thing. What about presence?

Or should we force inheritance clause? That would make it easier for a beginner not to forget to give the instance a class when they intend to. I strongly think YES!</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>compiler/testing/sgcrash1 displays multiple "'box' not defined"</desc>
<notes>This occurs at a initial location clause:

The ... In box</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>EMPTY &lt;location&gt; &lt;where&gt;</desc>
<notes>
Or possibly LOCATE ALL &lt;condition&gt; &lt;where&gt;

This was prompted by the darkness and light example, the problem being that objects at the location are described by the implicit LOOK performed when locating the hero there.

Possibly is nullified if DESCRIPTION CHECK is introduced.

The For Each construct with IN &lt;container&gt; or AT &lt;location&gt; can be used to move everything out of the container.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>How to read the end point of a direction?</desc>
<notes>
Suggested by Andrew Duncan Heale &lt;helix@yoyo.cc.monash.edu.au&gt;

Possibly we could have directions as some kind of instances of a class direction and then allow expressions of this type. Also a location could be a container which takes direction?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verify $&lt;n&gt; w.r.t the syntax parameters</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Depending On with aggregates</desc>
<notes>
and other variants (other than the standard binary operator)</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Prohibit recursive LOOK</desc>
<notes>
Check for 'locate hero'/'look' in DESCRIPTIONS (to prohibit "recursive look")</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Darkness and Audible</desc>
<notes>
How to handle darkness and other global requirements on e.g. the  location descriptions? This could possibly be handled by aspects of the descriptions, e.g. VISUAL DESCRIPTION, AUDIAL DESCRIPTION. These could be turned on/off using something like VISUAL ON. This would do away with the ever present test in the descriptions of dark locations.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>New Expression: ALL &lt;expr&gt;</desc>
<notes>Extend &lt;what&gt; to be also

"ALL" [ &lt;condition&gt; { "AND" &lt;condition&gt; } ]

which would allow:

LOCATE ALL HERE AT cave.
MAKE ALL OBJECT WITH size &gt; 3 heavy.
SET state OF ALL creature HERE AND IS hungry TO 0.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Isa DIRECTION</desc>
<notes>Allow ISA DIRECTION in syntax restrictions? OK, how do we then perform the natural

SYNTAX
 go = go (d)
  WHERE d ISA DIRECTION
  ...
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>EXIT out TO RETURN ....</desc>
<notes>Could be more needed with inherited exits...

Should probably be

  Exit out To this.

Only requires expression instead of ID in grammar.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>EXIT ELSE ...</desc>
<notes>Would be nice when exits are inherited. An author could then customize the "You can't go that way."

But isn't that awailable in the MESSAGES section?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow syntaxes that start with an object</desc>
<notes>In german (from sturmkoening2k):

    fallenlassen = (obj) * fallenlassen

Hmm, it's not a great deal to use:
   lasse_fallen = lasse (obj) * fallen
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>SCORE &amp; MAXSCORE as variables</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Continued player input dialogue</desc>
<notes>&gt; THE BALL
What do you want to do with the ball?
&gt; KICK IT
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>SCENERY word, word, word</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Font sensitivity (esp. proportional fonts)</desc>
<notes>No. Leave this to a graphics layer such as GLK.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>METAVERB, takes no tick</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Exit directions in the status bar</desc>
<notes>Suggested in a mail from sturmkoenig2k@t-online.de</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor: Make compiler node types be pointers?</desc>
<notes>make the types be pointers instead of nodes ("ClassNodePtr cla" instead of "ClassNode *cla")?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>xglk library problem</desc>
<notes>Report to Zarf about the || -&gt; &amp;&amp; problem and the inconsistency on resource files (Windows look them up using extension, xglk assumes no extension). Does blorb manage them with numbers only? Yes. So that is more portable.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Report mingw startup problem</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add PowerUpdater</desc>
<notes>Really? Or create own update script on Thoni IIS?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>change "*_x.h" to "*.x"?</desc>
<notes>
No, since that would break *.[ch] convention.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Capitalized names is a problem in parameters since printing of them use player input (Step 2)</desc>
<notes>E.g.
  &gt; talk to mr x

Does not output

  Mr X does not want to talk to you.

This is because the 'x' is in the player input. This design was made so as to not reveal objects secret properties:

  &gt; examine rod
  You can not examine the dynamite.

Is it possible to do both? Current view is that a the feature with hiding names is an author responsibility. E.g he/she must program the mentioned clause to take care of this if required.

Step 1: Don't ever use player input

Step 2: Even better, but much harder would be to create default mentioned clauses by listing the word-numbers to show. (A words number would be the number of the lower case version of the word). Then a Say could select the words the player input but show them in the case the author wanted.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>'again' verb</desc>
<notes>Requires meta-handling like 'undo'</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Strategies</desc>
<notes/>
<priority>2</priority>
<origest>8</origest>
<currest>8</currest>
<elapsed>2</elapsed>
<isopen>0</isopen>
<task>
<desc>Restrictions can only restrict to one class</desc>
<notes>It will not be possible to handle:

 Where o Isa object Or location ...

Can only allow one class in a restriction.

Affects anress() (no loop).</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Containers</desc>
<notes>
Containers are only properties of instances (possibly inherited of course).

Restrictions must allow "Isa container"

No "pure" containers.

You can not define a class "container" as that would shadow the built in handling of restrictions "Isa container".

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Thoughts about locations and surroundings</desc>
<notes>
START AT et.al "location" requiring statments/expressions do really only need the SURROUNDINGS slot (not necessarily inheritance from LOCATION), but is this wise? inheritance from "location" is easy to  understand and also makes DESCRIPTION and NAME have only one meaning since instances can not be both traversible and tangible.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Location Names and Mentioned</desc>
<notes>
Single inheritance and the fact that location, object and actor are predefined classes is used  to restrict the generality. So an instance can not be a traversible location and a tangible object at the same time.

A location will execute its "mentioned" as the Entry label. So any Mentioned clause will overwrite the Names clause. (Warn for this)

An object will have "mentioned" as the SAY statements.

Actors and object will generate a "mentioned" from the first NAME clause. If non exists the identifier will be used.

Mentioned will be used in LISTs, and when no DESCRIPTION exist.

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>SAY Location = NAMES but SAY Object = Mentioned</desc>
<notes>
How should the interpreter handle this difference?

The Mentioned code slot will be used for both locations and objects.

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Articles</desc>
<notes>
V2 article was only indefinite, because that was what was mostly needed. But to cater for various forms of money, water, etc. both definite and indefinite is needed.

E.g.

SAY THE o.

SAY A o.

to use the two articles. And 'o' could Mention o.


PROBLEM: which form will MENTIONED then be in? Or should DEFINITE and INDEFINITE specify the whole form?

This will mean e.g.

DEFINITE "the money"
INDEFINITE "some money"

and MENTIONED should be removed?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Attributes</desc>
<notes>
The attributes will have unique numbers so that the same number will be used whereever in the hierarchy it is.

The interpreter attribute tables will have this code in them (as opposed to v2.x)
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Scripts</desc>
<notes>
Scripts are analyze within the classes and instances that they are declared but not generated there. They are instead numbered uniquely and generated in a global list.

Look up is performed by traversing the inheritance tree.

This strategy makes it possible to use the same script code for all instances that inherit the same script.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Obsolete</desc>
<notes/>
<priority>2</priority>
<origest>6</origest>
<currest>6</currest>
<elapsed>0</elapsed>
<isopen>0</isopen>
<task>
<desc>Redefinition of base classes</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Maybe allow "Has neighbour Any object."</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>"no instance" constant ("nothing"?)</desc>
<notes>What happens if we use that as an initialization? Which type will the attribute get?

A better solution would be:

   Has No &lt;class&gt;.

But still what happens if there is no value? It is better and simpler to ensure that it always points to something. This will never fail, but &lt;no value&gt; will require author controls which we must assume are not always done.

So this is a bad idea!!</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Global CHECK?</desc>
<notes>
What is this for?
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Mapping from old syntax</desc>
<notes>
Not needed!
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>allow .ACD/.DAT as well as .acd/.dat</desc>
<notes>
MAC (or general?) this also goes for the names of save files, should be converted to lower case always</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>DONE</desc>
<notes/>
<priority>2</priority>
<origest>227.89</origest>
<currest>226.89</currest>
<elapsed>226.89</elapsed>
<isopen>1</isopen>
<task>
<desc>Allow lists of restriction classes and OR them together</desc>
<notes>
Why? So not done.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Include library in the release</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>AtrNod -&gt; Attribute</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Do we need wht?</desc>
<notes>
Yes. For WHAT_LOCATION, WHAT_SELF etc.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Done flag in ExitEntry for reverse</desc>
<notes>
Should be handle by separate bookkeeping in the reverse process instead.

Or rather the ExitEntry need to be divided into an extra list, the direction lists.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>-dump 1234 to dump at various points in the process</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>ELM could be SYMs?</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Entry types in acode.h</desc>
<notes>
So that the compiler can create an entry and emit() the whole entry instead of relying on remembering the correct order and number of fields.

Some done already.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>ID kinds</desc>
<notes>
SYMBOL, WORD

What is the difference between an ID and a symbol?

Should there be any IDKINDS? How about having a SYMBOL pointer instead?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Increment: version 3.0.00</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Moving from one location to another</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Objects at location NOT described if they have empty descriptions</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Objects at location described with own description</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Objects at location listed with own mentioned</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Objects at location described with default description</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Location described</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Location labeled</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Start At</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.01</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Testing of attributes on locations</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Setting of attributes on location</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Testing of inherited attributes</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Setting of inherited attributes</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Semantic check of exits in not locations</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Inherited locations</desc>
<notes>
Traversing between instances inheriting from location more than one level.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.02</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>MAKE statements</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Objects with attributes</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.03</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
<task>
<desc>Syntaxes for simple verbs</desc>
<notes>
Like QUIT, LOOK.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Object references in player commands</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.04</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Reference to a parameter</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Parameters take precedence</desc>
<notes>
The execution environment passed along in analysis will indicate Verb/Syntax. A symbol table lookup should find these identifiers before e.g. classes and instances.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Syntaxes with class restrictions</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Explicit syntax with parameter</desc>
<notes>
Define a verb and its syntax, then let expressions refer to the parameters in the syntax.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Default syntax</desc>
<notes>
Define a verb (but no syntax) and make a parameter refer to it.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>NAMEs on an object</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Execution Environment</desc>
<notes>
Requires parameter lists, possibly in class or instance. Analysis should allow:

- reference to LOCATION and OBJECT attributes for this class or instance (DESCRIPTIONs, EXITS, ...)

- reference to parameters attributes (Verbs)</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.05</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Initial location could be in a container</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>LIST statement</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Container restrictions</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Container handling</desc>
<notes>
&lt;ITEM -- Not a proper class
&lt;STRING&gt;
&lt;NUMBER&gt;
&lt;THING
&lt;OBJECT&gt;
&lt;LOCATION&gt;
&lt;ACTOR&gt;&gt;&gt;


But where is CONTAINER? A suggestion is that it could be a property slot which is potentially available for all THINGs. But it will have to be activated much like today:

Class box Isa Object
With Container
End Class box.

This would imply that the Container slot is added to a node in the class hierarchy much like an attribute. It will also be inherited in the same way. Checks for EMPTY &amp; LIST etc. could then be done by checking that the class of the argument has the Container slot, explicitly or inherited.

Note also that the Container slot can be added to a ENTITY declaration directly so there has to be a way to check:

IF o ISA Container THEN ...

or something similar.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verb execution in instances</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.06</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Bug: IT does not work in the interpreter</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Saviour</desc>
<notes>
Restructure to use classes instead of attributes.
But keep the attribute version for later.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add To Every xyz &lt;attributes&gt;</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Literals handling in the interpreter</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Redeclaration of The Hero</desc>
<notes>
So he can be made to have the container property, or should we have a new kind of clause:

Add To The Hero

No! The hero should be possible to redeclare. But it should be possible to add features to classes:

Add To Every object ...</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>The hero as a container</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.07</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Actors with attributes</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Events</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Debugger to handle instances and classes instead of objects et al.</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Bug: take all does not work</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Describe a present actor with default description</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.08</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Allow user defined classes in the restrictions</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Scripts to work</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Default container listing for actors</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>exp.class -&gt; expressionKind</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>NAME on location</desc>
<notes>
Should generate the "Mentioned"</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.09</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Inherited container properties</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Saving and restoring</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Default syntax for verbs only in instance</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.10</desc>
<notes/>
<priority>2</priority>
<origest>6</origest>
<currest>6</currest>
<elapsed>6</elapsed>
<isopen>0</isopen>
<task>
<desc>All actors should execute and rules should execute in between</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>What</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Remove objs &amp; acts in interpreter</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>anres() should be handed the VerbSymbol instead of the parameter list</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Bug: DEPENDING ON</desc>
<notes>
It should only execute the expression once. The current code generation and interpretation is wrong. Consider "DEPENDING ON RANDOM 1 TO 8".</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>SymNod -&gt; Symbol</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.11</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Warn for instances and classes without inheritance</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Must be able to restrict to a class AND container</desc>
<notes>
It must be possible to use attributes for parameters restricted to a class and container:

Syntax put_in = put (o) in (c)
  Where c Isa x Else ...
  And c Isa container ...

Verb put_in
  Does
    Id c Is attr Then
      List c.

So the resolvation must be able to accept or return multiple restrictions. Probably by traversing all the restrictions for the parameter and verifying with them.

This is the old "container actor" and "container object".</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Execution of verb bodies in parameters</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.12</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Where HERE</desc>
<notes>
Refer to the current location.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>HERE should also find things in containers that are not things (pure)</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow only names on scripts</desc>
<notes>
So that we can do a simple numbering scheme of them like with attributes when preparing for inheriting them.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.13</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Reference to attributes to class identifiers should be prohibited</desc>
<notes>
E.g.

Every x
  Is y.
...

... If x Is y Then

Should generate an error.

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>LOCATE AT Current Location</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>DESCRIBE statement</desc>
<notes>
To work with objects and actors.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>atr Of Current actor</desc>
<notes>
In all references to attributes</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>atr Of Current location</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.14</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Document Current Actor/Location</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verbs in current location should be executed</desc>
<notes>
or shouldn't they? If so, exactly when?
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verb alternatives</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verb names must not be redefined</desc>
<notes>
In anvrbs() traversing is done to ensure this fix that wrt. ids</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Text stored in the .ACD</desc>
<notes>
Instead of creating a separate .DAT file we could store the text in the end of the .ACD file and just add the .ACD size to every texts file position.

Also changed extension to .A3C
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.15</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Updated manual</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>WinGLK</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.16</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Inherited DESCRIPTION</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document classes in the tutorial part of the manual</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>ADD TO misses some attributes sometimes</desc>
<notes>
So I did a little more playing with a little test game. It might be that a
second "add to &lt;something&gt;" is not properly processed unless some other sort
of code has been compiled in the meantime. But I'm not sure I've worked out
the pattern yet. With the following game, I switched the order of the "add
to"s and changed "thing" to "object" a few times to try to follow it.
Hopefully you'll be able to work out what's going on.

I tried compiling my test file with Alan 3.0.6, it displayed the same
behaviour as 3.0.15. So the problem has been around for a few versions.

If you can't fix it yet but can discover a work-around then please let me
know. (One thing I've thought of, is that I could concatenate all the
scattered "add to's" for each class into one just so I can get a working
library for 3.0.15.)

-------------------------------
add to every thing
is big.
end add to thing.

--add to every thing
--is takeable.
--end add to thing.

add to every object
is takeable.
end add to object.

add to every object
is heavy.
is hard.
end add to object.

verb take
does
if object is big then
"object is big"
end if.
if object is heavy then
"object is heavy"
end if.
if object is takeable then
"object is takeable"
end if.
if object is hard then
"object is hard"
end if.
end verb take.

the aaa isa location
end the aaa.

start at aaa.

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>LIMITS to use inherited attributes</desc>
<notes>
add to every thing
has
bulkiness 10.
end add to thing.


the jug isa object
container
limits
count 10 then
"Too much stuff"
bulkiness 50 then
"too heavy"
end the jug.

the aaa isa location
end the aaa.
start at aaa.

(From Steve G.)</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.17</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>If a SAY refers to a parameter the print out should use the same words</desc>
<notes>
This is today done when "$o" is used, but should be implemented for SAY generally. So SAY must investigate if the instance was one of the parameters and if so use the words the player typed.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Class expression</desc>
<notes>
&lt;thing&gt; Isa &lt;class&gt;

Will check if the item refered to as the &lt;thing&gt; belongs to &lt;class&gt; or a subclass to it.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document the THIS primary</desc>
<notes>
When and where it is applicable</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactoring: find inherited description in the interpreter</desc>
<notes>
We must generate description for the classes!

The classEntry need to be almost the same as the instanceEntry. This means that we can factor out the generation of common data. Semantic checks will have to prohibit use of non-class slots.

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>WinGlkArun should use the file open dialog if no parameter</desc>
<notes>
Argument handling in WinGlkArun seems a bit messy...</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Describe the typical Alan "application" in the manual</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.18</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>DESCRIPTION CHECK/DOES</desc>
<notes>
By changing (or at least allowing) the description clause to

 Description
   Check Location Is lit
     Else "You can not see anything."
   Does
     "Some description..."

We can finally crack the elusive darkness problem by defining:

 Every dark_location
   Isa location

   Description
     Check

Remember that the Check and the Description should be inherited separately.

The Checks should also be additive so that all checks in the inheritance chain must pass.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor SLOTS to be PROPS</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.19</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>For Every x Isa &lt;class&gt; Do xxx End For. (BLOCK, LOCALS A-code part)</desc>
<notes>
To implement this we need a BLOCK, ENDBLOCK and a LOCAL instruction.

The BLOCK instruction should take a number indicating how many words to allocate on the block locals stack for this block. The ENDBLOCK should pop that many from the locals stack.

GETLOCAL &lt;l&gt;, &lt;n&gt; would get the local variable with index n in the current block if l==0 or l blocks down if it is not.

It should be recursive in that each time a new block is entered the current block pointer is pushed and a new pointer allocated by pointing to a new "top" in the stack.

This time around we use the normal stack, this means:

BLOCK &lt;n&gt; : push the current BLOCKPOINTER, save the current stack pointer into the BLOCKPOINTER, push n words, 

GETLOCAL &lt;l&gt;, &lt;n&gt; : access the n:th word above the current BLOCKPOINTER (bp+n) and push it. If l != 0 look l blocks down.

BLOCKEND : restore stackpointer from BLOCKPOINTER, pop BLOCKPOINTER



</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Bug: attribute type mismatch refers to the current class</desc>
<notes>
Inherited attributes which override others with another type should refer to the original class instead of the current one. See compiler/testing/inheritedAttributeTypeError
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>About Arun box in interpreter</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>bogus article re-declaration bug</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.20</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Inherited verb bodies</desc>
<notes>
See "Execution of verbs at various places"

But for now simply inherit the bodies and preserve any current quirks. Should we do this by replicating? Or by pointing to the same code in the classes? How do we then identify the verb body, they do not have unique identifiers...

Generate the verbs in the classes and let the interpreter find the body in the same way as now (also looking up the class hierarchy).

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Nested contexts</desc>
<notes>
It must be possible to nest contexts so that THIS can be looked up in a Verb context inside a Class or Instance context.

Well, VERB_CONTEXT with a class != NULL is equivalent...

But it is implemented now so...</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow WHEN ... THEN ... END WHEN</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Inherited scripts</desc>
<notes>
If there are only inherited scripts for an instance we still have to generate the info to keep status. Is there really any such info or is that kept in the general status record?

No it's in the admin record so we should be ok.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Current instance should change when executing verb bodies in parameters</desc>
<notes>
Verify this!</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>ADD should not allow overriding inheritance</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>For Every x Isa &lt;class&gt; Do xxx End For. (EVERY, ENDEVERY Acode part)</desc>
<notes>
New instructions:

FOR n : increment LOCAL n, if bigger than number of instances skip to (and over) corresponding ENDFOR

ENDFOR : skip backwards to corresponding FOR
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor so that scripts are generated only once</desc>
<notes>
Currently they are simply copied in replicateScript() so that they are generated  once for every instance inheriting them.

Instead all scripts should be generated in a common table, each script having its own unique id-code. (They could have the same name, since scripts are scoped within their containing class.)

This implies collecting a scriptList during analysis, keeping only script references in instances and a global script table in the interpreter.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor: All anxyz() -&gt; analyzeXyz()</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor: All gexyz() -&gt; generateXyz()</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verify that THIS works in Verb bodies</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.21</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>0</isopen>
<task>
<desc>Try CHECKs in the complete inheritance tree</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Run Verb bodies in the complete inheritance tree also</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>ADD TO Verb</desc>
<notes>
Add verbs to classes
Just concat the new verbs to the class

Unsuspend regression/save and regression/saviour



</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Global verbs should only be allowed without parameters</desc>
<notes>
and have the default syntax 'v' = 'v'

Remove global verbs from the interpreter verb look up.
OK


Add a default syntax without parameters.


Rewrite documentation.
Add a conversion hint about global verbs -&gt; entity class.


Prohibit syntaxes with parameters for global verbs.


-----

How do we handle the situation when the same verb is available globally and in instances/classes?

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>For Every x Isa &lt;class&gt; Do xxx End For. (code generation)</desc>
<notes>
No reference to the variable in this version. So syntax is

 For Every x Do ... End For.

Analysis of contained statements.

Code generate like this:

BLOCK 1
SETLOCAL 0, 1, 1 /* Set local variable 1 in this block to 1 */
EACH 1 /* 1 is the local variable)
...
ENDEACH
ENDBLOCK
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Locations should not be things?</desc>
<notes>
This would make it more natural to add attributes etc. to objects and actors.

In particular verbs is tricky since you would probably not add the same verb to locations too:

Add to every thing
  Verb talk_to
    ...
End Add.

This would make every *location* have the talk_to verb and we don't really want that.

So the predefined classes should have a top level class (entity) which thing and location inherits from. DONE!

Document this!</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>THIS should be defined in classes</desc>
<notes>
It is!</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>List node type indicator</desc>
<notes>
A field in the list type that indicates list type.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Literal values in the interpreter</desc>
<notes>
litValues[lit-LITMIN] &amp; isLit()</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Point to Slots from Symbol instead of having attribute lists</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Symbol kinds:</desc>
<notes>
What is a SYMBOL? Only id's that we need more info on, like

CLASS, INSTANCE, VERB, PARAMETER (but not in symbol table)

Not ATTRIBUTE, WORD (in dictionary), EVENT (not needed), SCRIPT
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>What are names?</desc>
<notes>
And when to use them? Actors previously was default-described using:

 interpret(name);
 msg(SEE_ACT1);

Objects are now default-described by the mention-clause which is generated by the compiler.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.22</desc>
<notes/>
<priority>2</priority>
<origest>10.06</origest>
<currest>10.06</currest>
<elapsed>10.06</elapsed>
<isopen>0</isopen>
<task>
<desc>Pre-defined classes literal, integer &amp; string</desc>
<notes>Need to have those class numbers also in the interpreter (ACODE.h)

Parameters should refer to those classes so that they work as all other parameters.

Remove isLit()?

Document!</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Remove keywords: integer, string</desc>
<notes>Requires syntax restrictions to handle those cases by using the built in classes instead.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>"You can't instantiate from class 'integer'"</desc>
<notes>
Goes for literal, string &amp; literal</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Entities are everywhere</desc>
<notes>Possibly things are restricted to only be present at a location, entities and locations are present everywhere but not show.
Interpreter should only display Things

Make sure that the interpreter don't display them and document that.

Document.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Can't add attributes etc. to literals</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verb without alternatives should by default be 1?</desc>
<notes>
Maybe a verb body without a WHEN p should default to When #1.
Except when in a location.

This could perhaps fix the problem with location verbs not working in a "global verbs without parameters" environment.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Update library to not use global verbs</desc>
<notes>Change library to use ADD TO ... VERB instead
Add test case to compile it.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Prohibit global verbs</desc>
<notes>Replace by verbs in appropriate class.
Document.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Instruction trace during IF</desc>
<notes/>
<priority>2</priority>
<origest>0.02</origest>
<currest>0.02</currest>
<elapsed>0.02</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Remove CVS operations in ok-regression script</desc>
<notes/>
<priority>2</priority>
<origest>0.02</origest>
<currest>0.02</currest>
<elapsed>0.02</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>For Every x Isa &lt;class&gt; Do xxx End For. (Class restriction)</desc>
<notes>
Add semantics to FOR EACH syntax (15)
Verify that the class identifier is a class. (10)
And loop only over those entities. (60)

Code generate:
EACH 1
ISA 1, class
NOT
IF
NEXT
...
ENDEACH
</notes>
<priority>2</priority>
<origest>0.02</origest>
<currest>0.02</currest>
<elapsed>0.02</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Only sub-classes to actor may have scripts</desc>
<notes>
Verify and produce an error.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Warn for locations with container property</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.23</desc>
<notes/>
<priority>2</priority>
<origest>7.83</origest>
<currest>7.83</currest>
<elapsed>7.83</elapsed>
<isopen>0</isopen>
<task>
<desc>FOR EACH &lt;id&gt; ISA &lt;class&gt; DO ... &lt;id&gt;</desc>
<notes>Create a temporary structure in the symbol table
This structure should be refered to first to see if the identifier is there

Requires:
  Two new calls newFrame and killFrame
  A Frame stack in the symbol table.

DONE:
- Frame handling
- Local symbols

TODO:
- Calculate levels below from frame level (how to remember frames during code generation?)
- Generate GET/SET-LOCAL from ID with symbols of LOCAL kind</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verb bodies should by default apply to all parameters</desc>
<notes>Default parameter for a WHEN-less verb body should be reset to 0 (meaning it will execute for all parameter places).
(It did not work to force a WHEN clause, this was not the common case).
Document this behaviour and point out that if a verb body gets executed more than once you should consider a WHEN clause on that verb.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Warn for verb bodies with no WHEN clauses if it has more than one parameter</desc>
<notes>Verbs in locations are represented by the parameter number -1, a no-when-clause body by 0, and others by their parameter number</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Adding a Verb that is already present gives sub-optimal error message</desc>
<notes>Design:
Refactor out a function verbAlreadyDeclared() which takes an existing verb identifier and looks for it in a verb list.
This could be called from both analyzeVerbs() and addVerb().

Requirement:
See exampe, a better message would be "Can not add because it is already defined for obj." Would require a loop like the one in property analysis, which could probably be refactored out.

addVerb.alan

    1.  Every obj Isa object
    3.    End Verb.
    4.  End Every.
    5.
    6.  Add To Every obj
    7.    Verb x Does "x/y"
=====&gt;         1

  *1*   220 W : Multiple definition of verb 'x' in this context.

    8.    End Verb.
    9.  End Add.
   10.
   11.  The l Isa location
   12.  End The l.
   13.
   14.  Start At l.
   15.

        No detected errors.
        1 warning(s).
        1 informational message(s).</notes>
<priority>2</priority>
<origest>0.83</origest>
<currest>0.83</currest>
<elapsed>0.83</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document verb lookup, especially for alternatives and locations</desc>
<notes>Remember that a verb added to an entity will be inherite by both locations and things and will be executed for both the current location and the parameter(s)</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Mentioned clause in location should override Name clause</desc>
<notes>Also warn for this.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Prohibit SAY for boolean attributes</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Warn for verbs added to entity</desc>
<notes>
.. since this is inherited by both locations and things. Probably they mean to put it on things.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.24</desc>
<notes/>
<priority>2</priority>
<origest>7</origest>
<currest>7</currest>
<elapsed>7</elapsed>
<isopen>0</isopen>
<task>
<desc>ISA expression</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Multiple restrictions for the same parameter</desc>
<notes>Must allow for gradual refinement of a parameter in a restriction:

Where p Isa thing Else ...
And p Isa object Else ...
And p Isa movable_object Else ...

Analysis should verify that later restrictions restrict to subclasses of the earlier.

This also should be noted in the symbol-&gt;fields.parameter.class so that the most restrictive is used.

Also check "Restrictions can only restrict to one class" in Strategies
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>ACTOR might be a container</desc>
<notes>If
  Add To Every Actor
    Container
  End Add To.
has been done an actor is a container which is not recognized by verifyContainer()

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add To Every xyz &lt;container&gt;</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Class names when debugging</desc>
<notes>Tracing should include class name where code is declared.
If not present in A3C class names must be available.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document semantic restrictions for entity, literal etc.</desc>
<notes>Sections 4.14?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Menu-entries for open, save, restart, restore, debug, transcript etc.</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.25</desc>
<notes/>
<priority>2</priority>
<origest>10</origest>
<currest>10</currest>
<elapsed>10</elapsed>
<isopen>0</isopen>
<task>
<desc>Stop ACTOR</desc>
<notes>
To interupt an actors execution of a script you have to have an empty script and do:

USE empty_script FOR actor.

A separate statement would be better (INTERRUPT?)

Another suggestion would be:

STOP &lt;actor&gt;.

E.g.

stop Painter.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Clause on containers for removing things/Actor clash</desc>
<notes>
Actor-clash handling, i.e. what happens when an object is removed from an actor? How to specify if this is possible and what the actor does? Possibly a new clause in containers:

 EXTRACT
   CHECK monster Is sleeping
   DOES Make monster Not sleeping.

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Documentation is wrong about DEPENDING ON  syntax?</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Full listing on the screen misses lines</desc>
<notes>
Refer to compiler/testing/addVerb losing line 2</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add To Descriptions</desc>
<notes>Need to code generate separately until we bookkeep reversal addresses.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>List This. does not work.</desc>
<notes>See regression/testing/listThis</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>About-box should show version info</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Warn for instances not inheriting from anything, especially the hero</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>SIGSEGV when unable to open output files</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Check that DEPENDING ON works as it should</desc>
<notes>Yup!</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.26</desc>
<notes/>
<priority>2</priority>
<origest>10</origest>
<currest>10</currest>
<elapsed>10</elapsed>
<isopen>0</isopen>
<task>
<desc>Show "imagefile"</desc>
<notes>Use glk_image_draw() in the text window. Align with imagealign_MarginLeft. Possibly add Show "imagefile" [Left|Right] to use also imagealign_MarginRight.

Use glk_gestalt(gestalt_Graphics, 0) to verify if graphics is available.

Add glk_window_flow_break before every glk_image_draw and before every newline() and para().

PROBLEM: imagealign_MarginXXX is only allowed directly after a newline. Does it work to insert a newline before every SHOW?

DESIGN: create a list of ID:s that collects alla graphics files. Before code generation:
 - sort the files in alphabetic order
 - number them and put that in the ID:s, same names get same ID:s
 - copy the files to resource names (PICnn,ext)
Code generation then can pickup the resource numbers from the ID:s</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Move current.verb code from "secret" place after class restriction table</desc>
<notes>Seems like the flags in the EOS syntax element could be used. Verify that it is not used for anything else.

Remember to change the reverse routine.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>COUNT &lt;right hand side&gt; {AND/OR &lt;right hand side&gt;} &lt;where&gt;</desc>
<notes>New right hand side of expression to augment COUNT aggregate.

First step: DONE!
Allow for it in ACODE.

push initial aggregate value (different for MIN &amp; MAX!!
AGRSTART:  push 1 (instance index), twice
&lt;rhs&gt;: code to eval right hand side and leave true or false
AGRCHECK: if pop() == false then find ENDAGR else continue
&lt;rhs&gt;: code to eval, leave true or false
AGRCHECK: d:o
COUNT: add 1 (or attribute) to element below stack top (aggregate value)
ENDAGR: if top() &lt;= instanceMax then push(pop()+1) and go to code after AGRSTART else pop() of instance index revealing aggregate value

Second step:
Allow one right hand side. DONE!

Third step:
Allow concatenated right hand sides. If no ISA use "Isa object" by default for compatibility reasons?? No. DONE!</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Bug: 1 + 1 = 2 parses unnaturally, requires (1+1) </desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verb declarations with multiple verbs</desc>
<notes>Possibly by introducing an intermediate level we could fix the problem with parameter references such as in

 give_to = give (obj) to (act)
 give = give (act) (obj)

 verb give, give_to
    make obj ...  -- obj is parameter #1 in give_to and #2 in give!!

Also need to consider how to warn for the same verb declared without a parameter at global level and with a parameter. Is this the same as declaring it with two separate syntax declarations? No, if done so the compiler complains.

DESIGN: Change to verb code in the syntax to a syntax code. Number all syntaxes. For each syntax connect it to a verb, Choose one syntax to represent the canonical parameter order. For each syntax create a table that maps the parameters to the canonical order.

TASK: Introduce the syntax mapping table, first to map to the same order.
TASK: Map parameters through the mapping table
TASK: allow multiple syntaxes for same verb
TASK: create multiple entries for same verb in syntax mapping table
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Multiple but different syntaxes for same verb</desc>
<notes>
For multiple syntax verbs to be really useful it should be possible to use the parameters in different order in the syntaxes:
Syntax give_to_actor = give (thing) to (person)
Syntax give_actor = give (person) (thing)
Of course it would then also be handy, almost required, to be able to create "verb synonyms". Currently you would have to add them both to every verb definition. So this complexity is one reason why the "multiple syntax verb" feature has not received very much attention.
To implement multiple but different syntaxes for the same verb a mapping between parameter positions have to be made. E.g. in

Verb give_to_actor, give_actor ...

We will have to refer to either parameter 1 or 2 for a reference to thing depending on the syntax used. Some kind of mapping table could be used.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Missing lines in -full listing</desc>
<notes>Messages with only informational messages are not shown if listing is filtered using severity

e.g. alan -full inheritVerb1:
    1.  Every x
    2.    Isa object.
    4.      Does Say c.
=====&gt;               1

  *1*   310 E : Identifier 'c' not defined.

But  alan -full inheritVerb1 -info:

    1.  Every x
    2.    Isa object.
    3.    Verb v
=====&gt;         1

  *1*   231 I : No syntax defined for this verb, assumed 'v (object)'.

    4.      Does Say c.
=====&gt;               1

  *1*   310 E : Identifier 'c' not defined.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>If a printout start with a "." don't print a space even if needsp is true</desc>
<notes>This will make most uses of $$ go away.

E.g.
  "The" Say x. "$$."</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Default syntax with parameter</desc>
<notes>Does it work to refer to the default parameter "object"? Yes.
How about if it is an actor? No. Because the default syntax is "object Isa object" It should be "object Isa &lt;current class&gt;, but how do we know that?

Is it possible to defer the actual class restriction to execution? Or should we look at the class which has the verb definition? What about if it is in an instance, look at its class? Yes. DONE.

However, there is no possibility to have default restrictions work the same way since we have no idea in which classes the verb is defined. Remember that restrictions are declared together with the syntax which is declared once outside all entities.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>UNDO</desc>
<notes>Investigate the possibility to just reallocate new admin[] and instance[] tables after each turn and make undo backup.

Ok, need to save event queue, instance and admin as well as score table, which needs to be copied in init(),

Remember to handle last UNDO gracefully.

Did not work since the attributes are in the original code. How can we extract them to the dynamic area? Or should be rethink the whole undo thing:

Allocate one big dynamic area in which we copy instance, admin. Attribute areas are copied there for all instances and their new address noted in the instances...
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: v2.8.7</desc>
<notes/>
<priority>2</priority>
<origest>2</origest>
<currest>2</currest>
<elapsed>2</elapsed>
<isopen>0</isopen>
<task>
<desc>Parser confusion in v2.8</desc>
<notes>From Lydia:
I'm implementing a direction-based movement system. So, for instance,
I need the verb "left", as well as the verb "turn left".

The problem is, when "turn left" exists, ALAN ends up scrambling its
verb table, resulting in "left" become "quit".

This does not seem to happen with exit directions; for instance, I
can have an exit "north" and "turn north" will not smash the verb
table.

ANALYSIS:

This is a problem when a word is declared as a verb, and later in the source also as a "preposition".
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>$p, $n problem in new winarun</desc>
<notes>So sorry, but I have found a bug in the new ARUN for windows.

Apparently $n (new line) and $p (paragraph, aka one empty line) are 
indistinguishable. All my $p codes are doing the function of $n, and not 
properly producing a blank line.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.27</desc>
<notes/>
<priority>2</priority>
<origest>16</origest>
<currest>16</currest>
<elapsed>16</elapsed>
<isopen>0</isopen>
<task>
<desc>WinArun's about box shows WINARUNVERSION instead of real version</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Update library w.r.t. discovered WHEN-problem multi param verbs</desc>
<notes>Cf. Steves new library files</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Update Makefile to have dist for source</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>"Increase v Of this" not working</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor gealtent to use Entry</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Scores was not initialised from loaded data</desc>
<notes>To avoid reversing twice, restart does not load the program, instead it only initialises the dynamic data areas. Scores was forgotten.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Bookkeep reversing procedure to avoid reversing same structure twice</desc>
<notes>Implementation: Strategy implemented, to be copied when needed. Only need to add it to every reverse procedure.

It would be rather straight forward to book-keep all Aaddr:s that where reversed and avoid doing it a second time if the structure is such that multiple structures refered to the same substructure.

It would only be necessary to bookkeep structures that require it. I.e. ones that now point to the same address from multiple places.

This would allow code generating once for some inherited constructs:
-scripts
-descriptions
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Make interpreter automatically capitalize words after full stop</desc>
<notes>Currently might look "xyz. mr x ..." because you can not force NAME "Mr X" since that would be wrong in the common case ("You can not take Mr X.")</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Prohibit declaration of a container class</desc>
<notes>You can not define a class "container" as that would shadow the built in handling of restrictions "Isa container".</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Optimize generation of containers</desc>
<notes>We could (and already tried to) optimize the generation of container bodies by utilizing the fact that container bodies are reentrant and inherited bodies are pointed to from the instances.

This however requires that the code for a container body is not reversed more than once. As it is now this can not be avoided.

A prerequisite action would be to fix this multiple reversing problem.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Section in the manual to describe automatic formatting</desc>
<notes>Capitalization after full stop and paragraph.
No space before full stop.
$$ reset both auto-formattings.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Automate building the Windows install</desc>
<notes>sed the VERSION into the Inno Script, and use it also to name the setup.exe</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Opaque containers</desc>
<notes>Allow:

The box Isa object
  Opaque Container
  Verb open
    Does Make This open. Make This Not opaque.
  Verb close
    Does Make This closed. Make This opaque.
End The box.

I.e. the container has a state which controls if contents of it is listed and reachable. That state can be set using the special attribute "opaque" which is only present in instances that are containers.

Warn (in instances that are containers) for declaring them as they would hide the built-in attribute.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Parameters should be defined in syntax restrictions</desc>
<notes>This problem was discovered in give.i trying to do

   Where recip Isa container Else Say recip. "cant' carry anything."
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Converter program from 2.8 to 3.0</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Windows file selection dialogue for compiler</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.28</desc>
<notes/>
<priority>2</priority>
<origest>8</origest>
<currest>7</currest>
<elapsed>7</elapsed>
<isopen>0</isopen>
<task>
<desc>Capitalization of nouns</desc>
<notes>Think about a way to allow nouns to be capitalized, either automatic but preferably by author choice. C.f. german. Language option dependent?

design: Interpreter capitalizes last word in SAY routines, compiler generates this option for some languages.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Support for German</desc>
<notes>Initial version done. Will have to update when SAY forms are available.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Location ENTERED</desc>
<notes>The old DOES clause of locations is removed. Do we need it? If so it should be named ENTERED since it is more descriptive of what it means.

ADVENT requires full implementation.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Converter should convert all statements in CAVE</desc>
<notes/>
<priority>2</priority>
<origest>3</origest>
<currest>2</currest>
<elapsed>2</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Converter should set current directory to source file</desc>
<notes>Description:
Otherwise the includes won't work currectly. This is only a problem when executing from WinGUI.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>WinAlan</desc>
<notes>As it is impossible to use Windows app from the console and attach output to the console we will have to make a WinAlan.exe and an alan.exe

It should also work from the desktop by double-clicking. Output should go in same directory.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.29</desc>
<notes/>
<priority>2</priority>
<origest>19</origest>
<currest>19</currest>
<elapsed>19</elapsed>
<isopen>0</isopen>
<task>
<desc>Article handling</desc>
<notes>Need:
Instances are mentioned and described in a number of situations. Sometimes it is necessary to refer to it in an indefinite form and sometimes in a definite form. E.g

I can't open &lt;indefinite form&gt;.
You can't take &lt;definite form&gt;.

Analysis:
Maybe we need INDEFINITE &amp; DEFINITE forms but also PLURAL form and in the form "any xx". We could have sub clauses for ARTICLE,  PRONOUN an PLURAL

Design:
The article Isa b
  Definite
    Article "the".
    Pronoun "it".
    Plural "articles"
  Indefinite "any article"

Design? If an instance has a Mentioned clause it should be used instead of any default always. Mentioned should be in undefinite form. How then do Articles apply?

Not all languages have definite and indefinite articles that work well:

Definite "den"
Indefinite "en"
Mentioned "stol"

Perhaps:

Name stol
Definite Form "stolen"
Indefinite Form "en stol"
Plural "stolar"??? Need plural definite AND indefinite???

With corresponding:
Say o. : use Name =&gt; "stol"
Say The o. : use Definite =&gt; "stolen"
Say A o. : use Indefinite =&gt; "en stol"
Say Any o. : use Plural =&gt; "stolar"??? Not needed, use "I can't see any" Say o. "." for now.

We could have Indefinite Form and Indefinite Article both not allow both in the same declaration. "Say The x ."would then use Definite Form if there is one or construct it from Definite Article + Mentioned. "Say A x." would then use Indefinite Form if available, or else Indefinite Article + Mentioned.

Since Mentioned is constructed from the Name clause the following would work:

Every person Isa actor
  Definite Article ""
End Every person.

The mr_a Isa person
  Name mr 'Andersson'
  Name mr andersson
End The mr_a

Problem is still what to say when:

&gt; talk to mr andersson
I can't see any mr andersson here.

But the library could:

Syntax talk_to = talk to (p)! Where p Isa person Else

Add To Every person
  Verb talk_to
    Check p Is Here
      Else "I can't see" Say The p. "here."
  End Verb talk_to.
End Add To Every person.

Verb talk_to 

Do we really need all the four forms? Indefinite singular/plural and definite singular/plural?

Possibly there is also a fifth form, as in "I can't see *any* door here." But let's leave that for later.</notes>
<priority>2</priority>
<origest>6</origest>
<currest>6</currest>
<elapsed>6</elapsed>
<isopen>0</isopen>
<task>
<desc>Definite and indefinite article declaration</desc>
<notes>If a definite and indefinite article declaration is introduced the following can be made possible:

"You can not x" SAY A obj.

"You open" SAY THE obj.
</notes>
<priority>2</priority>
<origest>2</origest>
<currest>2</currest>
<elapsed>2</elapsed>
<isopen>0</isopen>
<task>
<desc>Indefinite Article declaration</desc>
<notes>Rename it an document it.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Definite Article declaration</desc>
<notes>Implement and document.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Printing of articles</desc>
<notes>How do we use definite and indefinite articles in printouts?

SAY the O.

SAY an O.

</notes>
<priority>2</priority>
<origest>2</origest>
<currest>2</currest>
<elapsed>2</elapsed>
<isopen>0</isopen>
<task>
<desc>SAY an/the &lt;param&gt;</desc>
<notes>A SAY should refer to which form of articles should be used:

 Say The x.  (embedded as $the x$?)
 Say An x.
 Say x.
 
Possibly later:
Say Any x.
Say No x,

Requires sections something like:

 Definite
  Article "a".

 Indefinite
  ""
</notes>
<priority>2</priority>
<origest>2</origest>
<currest>2</currest>
<elapsed>2</elapsed>
<isopen>0</isopen>
<task>
<desc>SAY An x.</desc>
<notes>New variant on the Say statement to use indefinite article. Implement it. Also change "Say x." to mean "Mention" (which it already should).</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Say The x.</desc>
<notes>New variant of Say statement to use Definite article + mentioned.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
</task>
<task>
<desc>Inheriting Definite and Indefinite articles</desc>
<notes/>
<priority>2</priority>
<origest>2</origest>
<currest>2</currest>
<elapsed>2</elapsed>
<isopen>0</isopen>
<task>
<desc>Inheriting Definite Articles</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Inheriting Indefinite Articles</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
</task>
<task>
<desc>Pronoun synonyms in player input</desc>
<notes>Personal pronouns are nice if allowed in input. "Him", "her" could be default synonyms for "it".</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Capitalizing of "proper_name" in library and doc</desc>
<notes>Steve mentioned that the library relies on v2 behaviour to automatically caps actor names.

Implementation:
- Document new behaviour. (DONE)
- Fix library. (To Be Done)

But proper_name is actually used to switch between using articles and names:

If x Has proper_name Then
  Say x. "looks at you."
Else
  "The" Say x. "looks at you."
End If.

This will not be required when definite and indefinite form printing is implemented.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Containers can take any type of instance, how to handle Limits?</desc>
<notes>Problem: if we can put actors in containers how do we handle attributes that might only be available on objects.

Step 1: prohibit containers to contain anything not an object? How?
What to do when an instance not an object is moved into the container?

Implement the structures for "Takes &lt;class&gt; Else &lt;statement&gt;" and use them with default &lt;class&gt; = object and &lt;statements&gt; "You can't put that in there."
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Column calculation bugs</desc>
<notes>$t does not move to next tab pos.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>"Describe this." Does not work.</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Multiple syntaxes for the same verb does not work for four</desc>
<notes>syntax x = a (x). x = b (x). x = c (x). x = d (x).

Generates wrong syntax tables for b and c.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Double click on a .alan file makes WinAlan fail to find the file</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Declaration of indefinite and definite forms</desc>
<notes>The forms should override articles</notes>
<priority>2</priority>
<origest>6</origest>
<currest>6</currest>
<elapsed>6</elapsed>
<isopen>0</isopen>
<task>
<desc>Declaration of Indefinite Form</desc>
<notes>Indefinite Form "en stol"</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Declaration of Definite Form</desc>
<notes>Definite Form "stolen"</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Say An x. to use Indefinite Form clause if available.</desc>
<notes>Should use Indefinite Form if available, else Indefinite Article + "Say x."</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Say The x. to use Definite Form if available.</desc>
<notes>Should use Definite form if available, else Definite Article + "Say x."</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Inherit Definite/Indefinite Forms</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Figure out the inheritance rules between forms and articles</desc>
<notes>The [in]definite will be investigated in this instance first and its implementation will rule. If no form or article is defined in the instance the parents will be investigated until one is found. If that is an article the instance will be mentioned, otherwise it is assumed that the parent will implement the full form.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
</task>
<task>
<desc>Increment: version 3.0.30</desc>
<notes/>
<priority>2</priority>
<origest>9</origest>
<currest>9</currest>
<elapsed>9</elapsed>
<isopen>0</isopen>
<task>
<desc>List error messages in same order as they where generated</desc>
<notes>This is particularly important when syntax corrections leads to semantic errors. It is essential that they are show in that order. This change must be made in List.imp,

Design: add a counter field in the message entries and sort on those also.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Capitalized names is a problem in parameters since printing of them use player input (Step 1)</desc>
<notes>E.g.
  &gt; talk to mr x

Does not output

  Mr X does not want to talk to you.

This is because the 'x' is in the player input. This design was made so as to not reveal objects secret properties:

  &gt; examine rod
  You can not examine the dynamite.

Is it possible to do both? Current view is that a the feature with hiding names is an author responsibility. E.g he/she must program the mentioned clause to take care of this if required.

Step 1: Don't ever use player input

Step 2: Even better, but much harder would be to create default mentioned clauses by listing the word-numbers to show. (A words number would be the number of the lower case version of the word). Then a Say could select the words the player input but show them in the case the author wanted.</notes>
<priority>2</priority>
<origest>2</origest>
<currest>2</currest>
<elapsed>2</elapsed>
<isopen>0</isopen>
<task>
<desc>Automatic capitalizing of nouns (e.g in german) only worked for player said words</desc>
<notes>Now since the parameters don't use the player words this is invalidated. Probably should change strategy so that the player can input any word and the words are stored capitalized (if specified). This would possibly do away with the run-time capitalization and the impossibility for the player to input names of locations which are automatically capsed by the compiler.

Think this through and make a design!!</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Location names are capitalized by the compiler</desc>
<notes>If a reference to a location is made in a player command the output of it will be capitalized. Would it be better to have the interpreter do it? Probably not.

One solution is to leave location names as they are. This forces the author to use quotation to get location names in edit case. And will have to use multiple names if a player is to refer to them.

See regression/defaultSyntax1

There is a solution suggested in compiler/prop.c/analyseName()</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Embedded printout (definite form)</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Embedded printout (indefinite form)</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>String operators</desc>
<notes>concatenation
substring extraction
substring searching


&lt;s1&gt; + &lt;s2&gt;
Strip (First|Last) [&lt;n&gt;] (Word|Character) From &lt;s1&gt; [Into &lt;s2&gt;]</notes>
<priority>2</priority>
<origest>2</origest>
<currest>2</currest>
<elapsed>2</elapsed>
<isopen>0</isopen>
<task>
<desc>String concatenation</desc>
<notes>&lt;s1&gt; + &lt;s2&gt; as expression</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Substring extraction</desc>
<notes>Strip (First|Last) [&lt;n&gt;] (Word|Character) From &lt;s1&gt; [Into &lt;s2&gt;]</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Symbolic step and breakpoints</desc>
<notes>Implement a feature to make it possible to single step per source line.

Design:
- a new instruction LINE &lt;no&gt;, &lt;file&gt;
- generate a list of source file names to index into
- for every statement and expression that is generated also generate a LINE instruction
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>A LOCATE in an ENTERED causes interpreter loop if the actor is already there</desc>
<notes>Entered
  Locate x Here.

This clause should not be run if the actor x is already in the room.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.31</desc>
<notes/>
<priority>2</priority>
<origest>17</origest>
<currest>17</currest>
<elapsed>17</elapsed>
<isopen>0</isopen>
<task>
<desc>Attributes of class type</desc>
<notes>Attributes should be allowed to refer to other entities. This would require strict classing of them and verification of assignment of them. Such an attribute can only be changed to something a sub class of what it was initially set to. But on the other hand we must also be allowed to do:

LIST ontop OF box.

Or should we only allow this through use of temporary variables? If so how do we restrict it?</notes>
<priority>2</priority>
<origest>5</origest>
<currest>5</currest>
<elapsed>5</elapsed>
<isopen>1</isopen>
<task>
<desc>Instance Type in type system</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Attribute declarations of instance Type</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Code generation of instance attributes</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Expression syntax for accessing attributes of attributes</desc>
<notes>In order to refer to an attribute of an instance which is refered to by an attribute the expression syntax need to be changed so that it allows:

  Make otherside Of door open.
  Set size Of bag Of thief To 4.

Possibly at the same time we could introduce a new attribute reference syntax, e.g:
  Make door:otherside:open.
  Set thief:bag:size To 4.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Assignment rules for instance attributes</desc>
<notes>Requires actual value to be only subclasses of instance initial class.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
<task>
<desc>Type comparison rules for instance type</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
</task>
<task>
<desc>Unify error messages 408, 413 and 428</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Error 223 (executed for every parameter) is shown even if there is no body</desc>
<notes>Checks are always run it's the bodies that we have to warn for</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Bug: Spaces after $o at end of string</desc>
<notes>SteveG:
Firstly, I found that if a double-quoted string ends in $o or such like then the next string isn't followed by a space. I thought when concatenating bits of text that they were always split up by a space unless the $$ parameter was specified. The little game space.ala is attached to demonstrate what I mean.

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow reading player input from file</desc>
<notes>A '@' as the first character will make the interpreter read the rest of the line as a file name. It tries to open that file and read lines from it one at a time, as if the player had input them.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Scripting</desc>
<notes>It should be possible to give a command so that the interpreter can read a set of player commands from a file.

Design: @&lt;file&gt;? Read one line at a time and feed that into readline(), on error stop, remember to close the file</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Bug: Aggregates does not work</desc>
<notes>Should they only address objects as it says in the docs? No, probably it should have a class restriction as an optional clause and object as a default.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add To Every xyz &lt;scripts&gt;</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Priorities of operators stink</desc>
<notes>Count at l = 8
-&gt; '=' replaced by 'OR'</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>RESTART does not work well in WinArun</desc>
<notes>Choosing RESTART from the menu restarts the game but also seems to redo the last command from the input. A glk_stream not cleared?

Could not repeat this!</notes>
<priority>2</priority>
<origest>2</origest>
<currest>2</currest>
<elapsed>2</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Make distinction on words and symbols and identifiers</desc>
<notes>The manual should have a clear description of each. In "lexical definitions"?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>OSX porting feedback</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.32</desc>
<notes/>
<priority>2</priority>
<origest>18</origest>
<currest>18</currest>
<elapsed>18</elapsed>
<isopen>0</isopen>
<task>
<desc>Allow expression as actor in "Use script for..."</desc>
<notes>Investigate Stop actor.

Stop does not analyze its expression to be an actor.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>&lt;more&gt; should work when taking commands from a file</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add "Playback comamnds" to WinGLK menu</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Default save name in WinArun should be basename of game</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Bug: Multiple syntax verb declarations</desc>
<notes>The problem with multiple syntax verbs is that only the first one is actually checked in any consistent manner. Also it is not clearly defined when two syntaxes are compatible and allowed to use in the same verb declaration. At present the compiler only checks for same number of parameters and the same names. That is not enough to cover it, it should actually also create a class definition for each parameter for use in this verb which is the sum of all the class definitions of the two syntaxes for the parameter.
E.g.
Syntax a = v1 (p1) Where p1 Isa Object Or Actor ...
Syntax b = v1 (p1) Where p1 Isa Container ...
Verb a, b
Here a reference to p1 should be considered to be either Object, Actor or Container

Design:
At analysis connect a parameter list to the verb and use that instead of the syntax

Actually this is obsolete, since in v3 you can not do that, you can only specify one class.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Multiple messages for initial locations which are not declared</desc>
<notes>The t Isa object In unknown ...

results in:

310 E : Identifier 'unkown' not defined.
310 E : Identifier 'unkown' not defined.

Fix it!
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>SAVE &amp; RESTORE texts as messages</desc>
<notes>Currently the library (or verb) prints "Saved. OK" even if the save was aborted (like it can be in WinArun). This should instead be a message SAVE_OK and complemented with a SAVE_ABORTED. Same for RESTORE. Possibly they could be made into one OK and ABORTED messages.

This is handled by WinArun now.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Containers can take any type of instance, how to handle Limits?</desc>
<notes>Step 2:

Design:

New clause on containers:
    Container
        Takes thing  (Or: Of thing)
            Else ....</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow parameters as actor in USE statement</desc>
<notes>Need: to be able to start a specific script for a variable actor.

Simply allow an expression as the actor in USE statement, inheritance etc. will take care of the rest ;-)</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Programmer Pitch in manual</desc>
<notes>Alan is an application oriented language. It features constructs that are natural to an author of Interactive Fiction. Alan is a strictly typed, compiled, objectoriented language with single inheritance. Classes inherits properties from their superclasses. The class system allows polymorphism so that instances of subclasses are valid wherever a superclass is specified. There are no explicit types, instead types are inferred from the expressions.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow full stop/period/'.' as a sentence breaker in player commands</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Unify messages 311, 351, 410, 428</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow expression as What in Locate</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow expression as What in Where</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>New attribute reference syntax</desc>
<notes>Allow
    l:dark
instead of
    l is dark
and
    o:size
instead of
    size of o

Because it could be made more general:

The east_door
  Isa object.
  Has other_side west_door.
  Has size 4.
End The door.

... If door:other_side:size &gt; 3 Then

</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>The usage text for the compiler says that include directories are searched before, THATS WRONG!</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Refactor schedule to use Expression</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Remove REVERSED using the endian() function in sysdep</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.33</desc>
<notes/>
<priority>2</priority>
<origest>17</origest>
<currest>17</currest>
<elapsed>17</elapsed>
<isopen>0</isopen>
<task>
<desc>Sets</desc>
<notes>Some kind of list or array datatype, like TADS lists, with
appropriate operations (indexing, finding its length, inserting
an item, deleting an item).

(Greg Ewing in Alan-IF mailing list)

Analysis:
Requires initialisation e.g Has partners [x, y]
Should allow loop over
Should have RANDOM selection
Reference to element partners[i] (or possibly not)
Have to allow add (partners + &lt;instance&gt;) and remove (partners - &lt;instance&gt;)
Watch out for changing array while looping

Design:

declaration: Has set {x, y}.
Empty sets are not allowed. Set gets least common denominator class if instances. Can use integers and strings too.

add and remove:
Include &lt;expr&gt; in &lt;expr&gt;.
Remove &lt;expr&gt; from &lt;expr&gt;.
</notes>
<priority>2</priority>
<origest>4</origest>
<currest>4</currest>
<elapsed>4</elapsed>
<isopen>1</isopen>
<task>
<desc>Declaration of sets</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Include &lt;expr&gt; in &lt;set&gt;</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Remove &lt;expr&gt; From &lt;set&gt;</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Expression In &lt;set&gt;</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Handle comma as period. No space before.</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow dash and underscore within words in player input</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>A very large number of events will not restore correctly after a save</desc>
<notes>There seems to be no check for event queue size when reading events back from a save file</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>For loop Filters</desc>
<notes>Possibly we can port the aggregate filters to the For Each loop.

To get
  For Each &lt;class&gt; [&lt;var&gt;] Which &lt;filter&gt; { And &lt;filter&gt; } Do
  End For Each [&lt;var&gt;].


All below is done:
First (but useless) version would be

 For Each Do
 End For Each.

Next version would be

 For Each &lt;class&gt; Do
 End For Each.

Which could be extended to

 For Each &lt;class&gt; [&lt;var&gt;] Do
 End For Each [&lt;var&gt;].

This also implies analysis of references to &lt;var&gt; as being of &lt;class&gt;, and code generation of such references.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verify UNDO</desc>
<notes>Make test cases for each bit of information that is to be undone.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>QUIT message should allow UNDO</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>UNDO needs some kind of response?</desc>
<notes>Generally: UNDO should say something, standard messages?

Should we allow UNDO as a response to quit?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>UNDO does not affect heros position</desc>
<notes>Bug? Save current state also? Why is not current.location set to heros location?

We also need some way to re-output the state.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Change DEPEND case separator to 'THEN'</desc>
<notes>DEPEND does not work with identifiers in the cases
DEPEND On X
= bartender : ...

Doesn't work any more... If it ever did...

Change ':' to 'THEN'</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Set may not contain Strings</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Empty player input to forfeit player turn</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Script Step After n does not work</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verify converters handling of quoted ids especially for new reserved words</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Increment: version 3.0.34</desc>
<notes/>
<priority>2</priority>
<origest>41</origest>
<currest>41</currest>
<elapsed>41</elapsed>
<isopen>0</isopen>
<task>
<desc>Multiple distant objects for omnipotent syntaxes should say "I don't know which one"</desc>
<notes>Currently it results in "I don't see any x here."</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>BUG: multiple syntaxes sometimes results in a "You must supply a noun"</desc>
<notes>See regression/syntaxOrder
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Verify that an inherited set or reference attribute retains the type</desc>
<notes>It should not restrict the type to the initializers type. Or should it? No, document that the complete type of an attribute is defined at the top level, i.e. the top-most declaration of an attribute will define its type.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document attribute inheritance wrt. SET and REFERENCE</desc>
<notes>Infered class of referees and members, subclassing and that the original class is retained through out the hierarchy.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Inherit NAMES in an additive way</desc>
<notes>This would allow:

Every fruit
  Name fruit

The apple Isa fruit
The pear Isa fruit

&gt; take the fruit

Possibly this would create a need for OVERRIDE NAME, or in the same way for all properties inherited additive. Which ones are that?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Make INCLUDE a grammar symbol to only allow structured includes</desc>
<notes>Still need to do it in the scanner though...</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Auto-generated syntaxes should have a restriction</desc>
<notes>The restriction should match the assumed class of the parameter of course.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Inherit initial location</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Allow optional period after "Container"</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>List candidates which caused the ambiguity in input</desc>
<notes>* Although not strictly necessary, it would be nice if
the "I don't know which xxx you mean" message could be
improved to list the candidate objects, as other systems
do. Although it would be better to phrase it in terms
of a statement rather than a question, i.e.

   I don't know whether you mean the big blender, the
   small blender or the super duper blender.

unless you also intend to allow the question to be
answered.

This would be particularly helpful in the case of
!-arguments, since in that case the player may have
no readily available means of reviewing the set of
possible objects and their full names, in order to
find an unambiguous phrasing.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Clean up of pre-defined classes</desc>
<notes/>
<priority>2</priority>
<origest>4</origest>
<currest>4</currest>
<elapsed>4</elapsed>
<isopen>1</isopen>
<task>
<desc>Enforce inheritance</desc>
<notes>No instances or classes can be declared without a parent. Don't know what this would mean...</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Entities should be available everywhere but not show up in descriptions or lists</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Sub-classes to entities must behave like entities</desc>
<notes>Entities don't have location properties, nor are they described automatically. Document this and warn for a location property.

The same goes for all subclasses of entity that the player has made, or rather everything not inheriting from thing, since things are the subclass that adds location and automatic descriptions. Document this and implement it.

"Every topic Isa entity" should give all topics the non-location, non-description feature.

VERIFICATION: Only objects, and actors are automatically described. Things are not. But things have location?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Things should not show up, but only be available at their location</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Describe "scoping rules" and interpreter scoping viz-a-viz author code</desc>
<notes>There are a couple of ways to get instances into player "scope".

Interpreter finds instances and *then* calls author defined code.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>RANDOM IN &lt;container&gt;</desc>
<notes>Randomly select one of the instances in the container

Has type of the container TAKES</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Random In &lt;set&gt;</desc>
<notes>Returns one value in the set.

How to handle the empty set???? Run-time error obviously.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Container listings should not show up if it only contains things.</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Transitive AT/IN</desc>
<notes>Change At and In to always be transitive (where possible, "Locate x IN y" can obviously not be transitive) Introduce a modifier to AT &amp; IN, DIRECTLY which modifies the behaviour to non-transitive where appropriate.</notes>
<priority>2</priority>
<origest>3</origest>
<currest>3</currest>
<elapsed>3</elapsed>
<isopen>0</isopen>
<task>
<desc>IN &amp; AT operators</desc>
<notes>Change IN &amp; AT operators to both be transitive.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add DIRECTLY to syntax for all WHERE expressions</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Generate code for DIRECTLY</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Pronoun declarations</desc>
<notes>Need:
"You can not shoot at that." is not very logical when the target is a person. Neither is

     &gt; ask woman about Sally
      "Sally, is my daughter. I haven't seen her for twenty years now. I miss her so."

      &gt; ask her about the weather
       I can't see any Sally here.


Analysis:
To fix this we need a declaration of pronoun, e.g

The woman Isa person
  Pronoun her
End The woman.

Implementation requires:
 - grammar change
 - run-time execution
 - embedded string printing (only if we want to be able to use it in strings)
 - library change

Implementation:
- send number of unique pronouns to interpreter
- for each parameter save the instance in corresponding pronoun slot
- when pronoun is used in input look it up in the slot

How to handle the above example? Probably by looking in the scope for any instances with the given pronoun.</notes>
<priority>2</priority>
<origest>8</origest>
<currest>8</currest>
<elapsed>8</elapsed>
<isopen>0</isopen>
<task>
<desc>Grammar, internal form and dump</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Analysis</desc>
<notes>- Not allowed on Locations
- Add words to dictionary</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Generate reference lists</desc>
<notes>Each instance should have a list of words which can be used as pronouns for it.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Inherit pronouns</desc>
<notes>Pronouns should override. We can simply point to the definition higher in the hierarchy,</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add pronoun table to interpreter and update it with each parameter in the command</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>What happens if a pronoun word is the same as any other word?</desc>
<notes>The pronouns need to have unique numbers in sequence from zero so that an array can be used to store instance references in the corresponding "slot".

If another word class has already entered it in the dictionary it will receive that classes code.

Probably we want to have unique word code for every unique word, and then a code per class that needs a translation. This would probably also solve the other multi-class word problems...</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>How to handle multiple parameters?</desc>
<notes>The THEM_WORD is used to refer to all parameters in a previous multi command. Would this still work?</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Change M_WHAT_IT so that it uses the pronoun word instead of it</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
<task>
<desc>Player reference to single object using 'them'</desc>
<notes>Refer to regression/them where a pair of sunglasses illustrates the point.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Change M_NO_SUCH so that it uses the words the player used</desc>
<notes>This means setting a flag so that sayParameter() knows to use the player words and not the instance names.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Output names in correct case</desc>
<notes>Store names in dictionary in original case, compare to player input case-insensitive.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Remove special handling of actors with respect to definite/indefinite forms</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Parameter available for attribute checks in some MESSAGEs</desc>
<notes>Could be handy. This would require each MESSAGE-code to define the parameters available and to set up this before entering the analysis of the statements.

This would be really good for translations. E.g in german "kein" has different forms depending on case. So the constant string "Ich kann hier kein $1 nicht sehen." is not always correct. However, if messages had parameters we could implement:

Message CANTSEE:
  "Ich kann hier"
  If object Is neuter Then "keiner" End If.
  If object Is masculine Then "kein" End If.
  If object Is feminine Then "keine" End If.
  Say object. "sehen."


Design:

Messages to allow are:
M_WHICH_ONE_START
M_WHICH_ONE_COMMA
M_WHICH_ONE_OR
M_NO_SUCH

Possibly also (when refactored)
M_CANT
M_SEEOBJ1 et al.
M_CONTAINS et al.
M_CARRIES et at.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Add message handling for UNKNOWN word</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Wrong space formatting in regression inheritContainer</desc>
<notes>This is probably because it is an embedded symbol so after printing the symbo there is both a newline and the next character in the string is a space.

Newline need to set needsp = FALSE and output need to adhere to it when it has printed the symbol and ignore any leading spaces in the rest of the string.
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document PRONOUN</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document new messages</desc>
<notes>Also note the change in the conversion appendix
NOTE any instance for which noun in noSuch()</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Saved name of game in a save-file should not contain path</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Fix problem with OPAQUE attribute not being inherited along with container properties</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Document inheritance rules for each construct</desc>
<notes>Isn't it already?
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
</task>
</task>
<task>
<desc>Misc</desc>
<notes/>
<priority>2</priority>
<origest>6</origest>
<currest>6</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
<task>
<desc>Converter from 2.8 to 3.0</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Compile Compiler on Metrowerks</desc>
<notes>
Install Metrowerks
</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Recover STEAM?</desc>
<notes/>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Regr</desc>
<notes>
Could be a script which got:

CASE = *.alan
COMMAND = alan $case | arun $case &lt; $case.input

as parameters or .rc or some other configuration.</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>1</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>Fix Toolmaker code generation problem</desc>
<notes>
Nr man genererar kod tex alanCommon.h blir kllpositionerna fel vilket gr det omjligt att generera Alans parser mm. frn klltexterna i CVS.

Verkar bara glla om man kompilerar med Cygwin och kr i ett Windows-shell</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
<task>
<desc>SLOC counter for CVS</desc>
<notes>

Modified Lines::::::
Index: alan.c
======================================================
RCS file: C:/Repository/alan/compiler/alan.c,v
retrieving revision 1.43
diff -r1.43 alan.c
522c522
&lt;     if (dbgflg)                       /* Force debugging */
---
&gt;     if (debugOption)                  /* Force debugging */


Removed Lines:::::::::

Index: testing/susp
====================================================
RCS file: C:/Repository/alan/compiler/testing/susp,v
retrieving revision 1.1
diff -r1.1 susp
6d5
&lt;     cvs add $case.suspended 2&gt; /dev/null


Removed File:::::::::::::
cvs server: pre3/write.tst.expected was removed, no comparison available


Added File:::::::::::::::::
cvs server: write.input is a new entry, no comparison available</notes>
<priority>2</priority>
<origest>1</origest>
<currest>1</currest>
<elapsed>0</elapsed>
<isopen>1</isopen>
</task>
</task>
</task>
</tasktracker>

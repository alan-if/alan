        <task>
            <desc>AlanIDE</desc>
            <notes/>
            <task>
                <desc>AlanIDE v.0.0.9</desc>
                <notes/>
                <task>
                    <desc>New Class wizard</desc>
                    <notes/>
                </task>
                <task>
                    <desc>New Instance wizard</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Add converter feature</desc>
                    <notes>Need:
                        Load a v2 source file, trigger "Convert from v2" on some menu, reload output into editor
                        
                        Design:
                        Require a converter preference setting.</notes>
                </task>
                <task>
                    <desc>Update java-grammar with latest syntax</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Bug: Errors in files imported but not in project are not shown anywhere</desc>
                    <notes>This can cause a user to think that the compilation was successful. Cheapest solution is to remove the .a3c-file at least. Should really mark main file if no resource with the file name was found.</notes>
                </task>
                <task>
                    <desc>Only rebuild AST for changed portions of the tree</desc>
                    <notes/>
                    <task>
                        <desc>Introduce ModelUpdater</desc>
                        <notes>A ModelUpdater should be attached to the Document of the Editor and update the Editors model when the Document changes. It needs to implement ITreeContentProvider to be able to be connected to the Outline view.</notes>
                    </task>
                </task>
                <task>
                    <desc>Incremental compilation</desc>
                    <notes>Compile with the java parser to build ast and produce syntax error messages. When that is OK, run the alan compiler to generate the game. This should be done all the time, not only at save.</notes>
                </task>
                <task>
                    <desc>Add relative option to library path</desc>
                    <notes>The compiler is run with the project as its working directory. This constitutes a problem if the the library preference is not an absolute path. When set it is validated w.r.t. the AlanIDE install directory, so when the compiler is run a relative path will not point correctly.
                        
                        An option to set relative path that is not verified (just a string?) can be a solution. See mail traffic on alan-if</notes>
                </task>
                <task>
                    <desc>Decorate resource icons and editor tabs with compilation status</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Add "New Alan Source file" to menu</desc>
                    <notes/>
                </task>
                <task>
                    <desc>"Add import"</desc>
                    <notes>Automatically declare an import for a file. Consider the import path when generating the file name in the import statement.</notes>
                </task>
                <task>
                    <desc>Navigate from outline import to imported file following import paths</desc>
                    <notes/>
                </task>
                <task>
                    <desc>New import icons in outline (use eclipse/java, where to find?)</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Pending</desc>
                <notes/>
                <task>
                    <desc>Build dependency structure for imports</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Prompt to save dependent source files also at save</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Outline view should combine multiple items into one if sequential</desc>
                    <notes>E.g.
                        Syntax a = ...
                        Syntax b = ....
                        
                        will generate four nodes:
                        
                        S
                        a
                        S
                        b
                        
                        better would be:
                        
                        S
                        a
                        b</notes>
                </task>
                <task>
                    <desc>Select project location in wizard</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Icons in png-format</desc>
                    <notes/>
                </task>
            </task>
        </task>
        <task>
            <desc>Strategies</desc>
            <notes/>
            <task>
                <desc>Containers</desc>
                <notes>
                    Containers are only properties of instances (possibly inherited of course).
                    
                    Restrictions must allow "Isa container"
                    
                    No "pure" containers.
                    
                    You can not define a class "container" as that would shadow the built in handling of restrictions "Isa container".
                    
                </notes>
            </task>
            <task>
                <desc>Thoughts about locations and surroundings</desc>
                <notes>
                    START AT et.al "location" requiring statments/expressions do really only need the SURROUNDINGS slot (not necessarily inheritance from LOCATION), but is this wise? inheritance from "location" is easy to  understand and also makes DESCRIPTION and NAME have only one meaning since instances can not be both traversible and tangible.</notes>
            </task>
            <task>
                <desc>Location Names and Mentioned</desc>
                <notes>
                    Single inheritance and the fact that location, object and actor are predefined classes is used  to restrict the generality. So an instance can not be a traversible location and a tangible object at the same time.
                    
                    A location will execute its "mentioned" as the Entry label. So any Mentioned clause will overwrite the Names clause. (Warn for this)
                    
                    An object will have "mentioned" as the SAY statements.
                    
                    Actors and object will generate a "mentioned" from the first NAME clause. If non exists the identifier will be used.
                    
                    Mentioned will be used in LISTs, and when no DESCRIPTION exist.
                    
                </notes>
            </task>
            <task>
                <desc>SAY Location = NAMES but SAY Object = Mentioned</desc>
                <notes>
                    How should the interpreter handle this difference?
                    
                    The Mentioned code slot will be used for both locations and objects.
                    
                </notes>
            </task>
            <task>
                <desc>Articles</desc>
                <notes>
                    V2 article was only indefinite, because that was what was mostly needed. But to cater for various forms of money, water, etc. both definite and indefinite is needed.
                    
                    E.g.
                    
                    SAY THE o.
                    
                    SAY A o.
                    
                    to use the two articles. And 'o' could Mention o.
                    
                    
                    PROBLEM: which form will MENTIONED then be in? Or should DEFINITE and INDEFINITE specify the whole form?
                    
                    This will mean e.g.
                    
                    DEFINITE "the money"
                    INDEFINITE "some money"
                    
                    and MENTIONED should be removed?</notes>
            </task>
            <task>
                <desc>Attributes</desc>
                <notes>
                    The attributes will have unique numbers so that the same number will be used whereever in the hierarchy it is.
                    
                    The interpreter attribute tables will have this code in them (as opposed to v2.x)
                </notes>
            </task>
            <task>
                <desc>Scripts</desc>
                <notes>
                    Scripts are analyze within the classes and instances that they are declared but not generated there. They are instead numbered uniquely and generated in a global list.
                    
                    Look up is performed by traversing the inheritance tree.
                    
                    This strategy makes it possible to use the same script code for all instances that inherit the same script.</notes>
            </task>
        </task>
        <task>
            <desc>Obsolete</desc>
            <notes/>
            <task>
                <desc>Redefinition of base classes</desc>
                <notes/>
            </task>
            <task>
                <desc>Maybe allow "Has neighbour Any object."</desc>
                <notes/>
            </task>
            <task>
                <desc>"no instance" constant ("nothing"?)</desc>
                <notes>What happens if we use that as an initialization? Which type will the attribute get?
                    
                    A better solution would be:
                    
                    Has No <class>.
                    
                    But still what happens if there is no value? It is better and simpler to ensure that it always points to something. This will never fail, but <no value> will require author controls which we must assume are not always done.
                    
                    So this is a bad idea!!</notes>
            </task>
            <task>
                <desc>Global CHECK?</desc>
                <notes>
                    What is this for?
                </notes>
            </task>
            <task>
                <desc>Mapping from old syntax</desc>
                <notes>
                    Not needed!
                </notes>
            </task>
        </task>

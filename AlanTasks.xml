<?xml version="1.0"?>
<tasktracker>
    <task>
        <desc>Alan</desc>
        <notes/>
        <task>
            <desc>Increments</desc>
            <notes/>
            <task>
                <desc>Better debugger</desc>
                <notes/>
                <task>
                    <desc>Move debug out to Adbg</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Better debugger command language</desc>
                    <notes>The command language for the debugger should be something like:
                        
                        break
                        break [source : ] line
                        unbreak
                        unbreak [source : ] line
                        trace (stack|source|...)
                        untrace
                        next
                        instances
                        instance i
                        show { instance : } attribute
                        set { instance : } attribute = value
                        list [ file : ] line
                        where</notes>
                </task>
                <task>
                    <desc>Debugger should be able to set breaks on lines in other source files</desc>
                    <notes>How to reference other files? Syntax for a line-number?
                        &lt;file name&gt;:&lt;line number&gt;
                        
                        Also need to separate the path and the basename since the user will want to use just the basename. This must be done by changing the SourceFileEntry to contain two structs of fpos/len one for the path and one for the basename.</notes>
                </task>
                <task>
                    <desc>Debugger should verify date of source file</desc>
                    <notes>How do we do this? How do we know the date of the .a3c file? Is it possible to stat() the open code file?</notes>
                </task>
                <task>
                    <desc>Debugger should be able to set (and declare) level of trace</desc>
                    <notes>Current 's' and 't' commands are not compatible with the command line switch -t &lt;n&gt;
                    </notes>
                </task>
                <task>
                    <desc>Symbolic instance and class references in debugger</desc>
                    <notes>To do this we must generate the programmer names also, this is the symbol to use.</notes>
                </task>
                <task>
                    <desc>WinAdbg should debug in a separate window</desc>
                    <notes>This involves managing two separate in- and output streams. The simple glkio mapping will come into play, possibly it is possible to let the debugger switch streams.</notes>
                </task>
            </task>
            <task>
                <desc>Version 3.0beta1</desc>
                <notes/>
                <task>
                    <desc>When an extract check fails the command isn't aborted.</desc>
                    <notes>Check regression/currentInstanceShouldBeResetOnFailingExtract</notes>
                </task>
                <task>
                    <desc>Replace $genid with $&lt;identifier&gt; in autogenerated identifier names</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Column indication with -cc &amp; -ide switches</desc>
                    <notes>Circumstancial evidence shows that this might be off be a character or so.
                        
                        Add compiler/testing cases for this and make sure we do that for at leas DOS and UNIX line ending conventions.</notes>
                </task>
                <task>
                    <desc>Investigate why new version of Alan in Gargoyle does not play sounds and shows pictures.</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Examples for every syntax in the manual as a box</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Divide interpreter source into common, arun, gararun, glkarun, winarun</desc>
                    <notes>So the directory structure should be something like:
                        
                        alan
                        +compiler
                        +interpreters
                        ++common : arun.a
                        ++arun : arun.c
                        ++winarun : winarun.c
                        ++glkarun : glkarun.c
                        ++gararun : gararun.c
                    </notes>
                </task>
                <task>
                    <desc>Rebuild Makefiles to include rules.mk</desc>
                    <notes>If rules.mk contains build commands using some predefined platform, compiler and variant specific MACRO settings they could be made very simple, like:
                        
                        # Makefile to port Alan compiler to MacOSX
                        
                        OSDEFS =
                        COMPILERDEFS = -O4
                        LINKERDEFS = 
                        
                        include rules.mk
                        include sources.mk
                        include dependencies.mk
                    </notes>
                </task>
                <task>
                    <desc>Define MAC_PLATFORM et al. and GUI/CLI/GLK in the makefile</desc>
                    <notes>It is hard to find reliable compiler defined macros. It is better to feed them to the builds from the Makefile.
                        
                        Possibly the Makefile can automatically find which platform it is using 'uname'</notes>
                </task>
                <task>
                    <desc>GarArun</desc>
                    <notes>Done:
                        - should play special/resources including sound
                        - distributed as a slot in replacement, name = Alan
                        - uploaded to website
                        
                        Tasks:
                        Check if windows-dist contains all the .DLL:s that the build seem to require, possibly check with Tor</notes>
                </task>
                <task>
                    <desc>Allow initializing an empty set by just giving a class name</desc>
                    <notes>Currently sets must be initialized by adding at least one element. This requires that if you need to create an initially empty set the element must be removed.
                        
                        If a single identifier of a class is given in a set this is unambigously indicating which class the elements must be.
                    </notes>
                </task>
                <task>
                    <desc>Introduce "Where" &amp; "Location Of" expressions?</desc>
                    <notes>Inspecting and acting on locations where an instance currently is, is hard since the only way to do that is to use many If instance At.
                        
                        A way to find the where an instance is can be introduced by adding
                        
                        1) a pseudo-attribute 'location':
                        Describe location Of This.
                        Make location of This lit.
                        
                        Or
                        2) an expression
                        Describe Where This.
                        Make Where This lit.
                        
                        They might both be valid if Where expression would refer to the container in where it is?</notes>
                </task>
                <task>
                    <desc>Investigate the resolve()/allLength problem</desc>
                    <notes>In parse.c:resolve() there is a test for allLength &gt; 0, with a comment that "ALL has already done this", but there is also a "TODO: NO IT HASN'T"
                        
                        Is this actually true? We can only have one ALL, but the parsing code might return multiple matches, leaving them for resolve() to fix?
                        
                        Create a test case that exhibits the problem, if it exists.</notes>
                </task>
                <task>
                    <desc>Prohibit 'Locate l At l.' and "Locate c In c."</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Document Checks for "normal case"</desc>
                    <notes>Remember Anssis problem with the Check which performed the normal case, this prohibited use of ALL to be applicable to a "normal situation"</notes>
                </task>
                <task>
                    <desc>Add an "Identification" section in the language</desc>
                    <notes>This should be a string/value pair list pointed to by the header. This list is terminated by a EOF. &lt;DONE&gt;
                        
                        It can be used by the compiler to add arbitrary info like
                        
                        "Author"/"Thomas Nilsson"
                        "hip"/"hop"
                        
                        primarily intended to allow authors to insert identificating values into the Acode file, as requested by the Babel Treaty.</notes>
                </task>
                <task>
                    <desc>Enhance the status line in GarArun using styles?</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Refactor and unit test the args &amp; switches functions</desc>
                    <notes>Refactor out "basename()" and "testprogramname()" or some such</notes>
                </task>
                <task>
                    <desc>--warnings to turn off warning messages does not work</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Breakpoints set on a line higher than the highest in a file should give an error</desc>
                    <notes>Don't we store the linenumbers in the game? If so it should only be possible to set in those lines.</notes>
                </task>
                <task>
                    <desc>More Tor porting issues</desc>
                    <notes>use __APPLE__ not __macosx__ to detect for macosx.
                        
                        i think the makefile.glk may be broken, there are a lot
                        of files that are not listed but still needed.
                        
                        En sak till jag hittade nu: i openResourceFile() försöker du öppna
                        resursfilen med
                        en absolut sökväg. Det kommer inte fungera i de flesta glk-implementationer som
                        har sandlådat vanliga fil-accesser. Jag rekommenderar att du använder
                        glkunix_stream_open_pathname() eller bara använder filnamnet utan
                        sökväg.
                        
                        I showImage ignorerar du align-argumentet.
                    </notes>
                </task>
                <task>
                    <desc>Description on translation</desc>
                    <notes>Is the things in the manual insufficient?</notes>
                </task>
                <task>
                    <desc>Are only CHECKs with corresponding WHEN run?</desc>
                    <notes>Or should the WHEN only apply to the DOES-part?
                        
                        No, a WHEN must apply to checks also, which means that only checks with a matching WHEN should be run. Verify that they are!
                        
                    </notes>
                </task>
                <task>
                    <desc>How do we know that THIS ISA CONTAINER if guarded by a IF ISA CONTAINER?</desc>
                    <notes>If this Isa container Then
                        List this.
                        End If.
                        
                        Does this really compile?</notes>
                </task>
                <task>
                    <desc>Menu icons in Arun menu in Winarun</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Add To Every Container?</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Floyd example</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Settings dialogue for compiler on Windows</desc>
                    <notes>Need: we need to be able to give options to the compiler while still double clicking on it.
                        
                        Design:</notes>
                </task>
                <task>
                    <desc>Warn if loop variable hides some symbol</desc>
                    <notes>especially if it refers to a class because that probably indicates the misconception of:
                        
                        FOR EACH entity DO
                        
                        but that is not allowed:
                        
                        FOR EACH instance ISA entity DO
                    </notes>
                </task>
                <task>
                    <desc>Plural handling in the library</desc>
                    <notes>For example
                        
                        Add To Every Thing
                        Is Not plural.
                        End Add To.
                        
                        Message see_object_start
                        If parameter1 Is plural Then
                        "There are $01"
                        Else
                        "There is $01"
                        End If.
                        
                        You would need to adjust more standard messages. These 
                        things are described in the manual in section 4.14 and 
                        appendix D.1.
                        
                        Every instance that should be used as a plural would be 
                        declared with something like:
                        
                        The erasers Isa object At aplace
                        Name some erasers
                        Indefinite Article ""
                        Is plural.            -- This is the important 
                        part since we test it in the message
                        
                        You could avoid the deletion of the Indefinite Article 
                        by assuming that it should not be used if the instance 
                        is plural. Then the plural message should be:
                        
                        "There are $1"
                    </notes>
                </task>
                <task>
                    <desc>Consistency for empty property declarations</desc>
                    <notes>An empty Description signifies a description but an empty one. Possibly this should instead signify a return to the default. An empty should then be Description ""
                        
                        Check for consistency with other instances of local overides.</notes>
                </task>
                <task>
                    <desc>Obscure error message for aggregate filters without ","</desc>
                    <notes>"Count Isa object In inventory" (missing comma) parses as:
                        
                        "Count Isa object" "In inventory"
                        
                        which is correct but gives the confusing error message:
                        
                        *1*   311 E : Must refer to an instance.
                        
                        pointing to "count" since that is the left hand side of the assumed expression
                        
                        &lt;something&gt; &lt;where&gt;</notes>
                </task>
                <task>
                    <desc>Refactor: add a context.symbol</desc>
                    <notes>context.class &amp; context.instance both have symbols which are needed at some places</notes>
                </task>
                <task>
                    <desc>Literal should not inherit from Thing?</desc>
                    <notes>It should be a separate base class, or should it?</notes>
                </task>
                <task>
                    <desc>Refactor loop filters so that Between can be combined with others</desc>
                    <notes>Example in suspended regression/integerInSet</notes>
                </task>
                <task>
                    <desc>What happens if we don't strip spaces from strings? AKA How to make a map?</desc>
                    <notes>It is not possible to draw a map in ASCII-art since the compiler strips spaces from strings and replaces them with a single space.
                        
                        But what about using " "? If the first character in a string is a space it is preserved. If it works, document and add regression tests so that we don't lose the functionality.</notes>
                </task>
                <task>
                    <desc>Disambiguate using syntax restrictions</desc>
                    <notes>This is most reasonable, as suggested by Greg in mailing list.
                        
                        This would require:
                        
                        - making simple() return multiple instances even for non-all expressions
                        - signaling that this is an ALL-like multiple match
                        
                        Possibly ALL and multiple matches could be handled the same way, Indicate a non-explicit multiple reference, and let a later step (resolve()?) handle it.
                    </notes>
                </task>
                <task>
                    <desc>Problem with consequtive include's</desc>
                    <notes>If a file has include-directives directly after each other the return from one, e.g. when the included file does not exist, positions the next DEPRECATED message on the wrong spot.
                        
                        See compiler/testing/includeFile.alan</notes>
                </task>
                <task>
                    <desc>Warn for DOES preceeded by an unconditional CHECK</desc>
                    <notes>DONE for verbs
                        
                        TODO: Descriptions, ?</notes>
                </task>
                <task>
                    <desc>Converter should move global verbs with parameters into a class</desc>
                    <notes>Which class? Will "thing" do? Probably.
                        
                        Design:
                        For each syntax found, if it has parameters save the verb name in list. When encountering a verb with such a name add "Add To Every thing" around it.</notes>
                </task>
                <task>
                    <desc>Unify error messages</desc>
                    <notes>Check error messages and try to unify such as
                        
                        Multiple VERB '%1'
                        
                        with
                        
                        Multiple %1 '%2'</notes>
                </task>
                <task>
                    <desc>abug needs a function to list instances matching a string</desc>
                    <notes>See alan-if on 12/7 2005</notes>
                </task>
                <task>
                    <desc>winarun does not parse its command line</desc>
                    <notes>E.g.
                        winarun images -t
                        results in
                        Could not open "images -t.a3c"</notes>
                </task>
                <task>
                    <desc>Document what is built-in</desc>
                    <notes>Messages
                        Classes
                        Instances (hero)
                        Words
                        Pronouns</notes>
                </task>
                <task>
                    <desc>Split the manual into separate pieces</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Version 3.0beta2</desc>
                <notes/>
                <task>
                    <desc>Clean up old sections in the manual</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Use MinGW instead of Cygwin</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Website: describe collaboration using alandemo project on sourceforge</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Website: divide games listing into v2/v3</desc>
                    <notes>And list IFComp-games</notes>
                </task>
                <task>
                    <desc>Example: composite object</desc>
                    <notes>Like a box with a couple of buttons on it.</notes>
                </task>
                <task>
                    <desc>Modify Makefile to recompile only files dependent on GLK</desc>
                    <notes>Currently ARCH includes GLK setting which makes it necessary to recompile all source files between the various GLK implementations.
                        
                        It would be better if only files dependent on the setting of GLK would be recompiled (and possibly also where the only ones getting the -D).
                        
                        This would require a grep for GLK in *.c to investigate.
                        
                        Maybe this isn't so bad considering the problem to solve...</notes>
                </task>
            </task>
            <task>
                <desc>Version 3.0</desc>
                <notes/>
                <task>
                    <desc>Syntax description in the manual</desc>
                    <notes>Make sure the grammar syntax is clearly explained</notes>
                </task>
            </task>
            <task>
                <desc>Version 3.1dev1</desc>
                <notes/>
                <task>
                    <desc>Scope definitions</desc>
                    <notes>Go for Gregs suggestion below, but change the syntax of a SCOPE to:
                        
                        Scope topic_scope Is In known_topics.
                        
                        NOTE however that Greg's suggestion can be made more general since it allows a general expression:
                        
                        Scope topic_scope Is obj
                        Where obj In known_topics And obj Isa topic.
                        
                        -------------------------------------
                        
                        A suggestion from Greg:
                        
                        Another thought is that you may want to have more
                        than one verb sharing a scope definition. So
                        maybe the scope test could be moved out of the
                        syntax statement and into a new kind of statement:
                        
                        SCOPE topic_scope CONTAINS obj WHERE
                        obj IN known_topics.
                        
                        and then you would say
                        
                        SYNTAX ask_about = 'ask' a 'about' t
                        WHERE
                        t FROM topic_scope
                        ELSE "You've never heard of anything like that."
                        AND t ISA ConversationTopic
                        ELSE "That's not a valid conversation topic."
                        
                        This would also help to untangle the syntax of
                        the WHERE clause and make it clear which parts of
                        it are to do with scope and which parts are to
                        do with type determination.
                    </notes>
                    <task>
                        <desc>Restrictions should allow location tests?</desc>
                        <notes>But you could have restrictions which tested one 
                            parameter with a "location test". The semantics would 
                            be something like:
                            
                            1) if you use a location test for a parameter as a 
                            restriction, then you are in complete charge of scoping 
                            for that parameter
                            2) if you don't, the interpreter will use the standard 
                            method
                        </notes>
                    </task>
                </task>
                <task>
                    <desc>FAIL statement</desc>
                    <notes>Since QUIT can not know if a player entered a quit or failed a command the undo mechanism can not be handled well. If we introduce a FAIL statement and instruction it can have the undo, but quit should not.
                        
                        This requires a new instruction and new messages. This must be introduced so that earlier (alpha) games can still be played, i.e. last in the lists of instructions and messages.</notes>
                </task>
                <task>
                    <desc>New options for separator and punctuation character sets</desc>
                    <notes>Option
                        separators ",.!?"
                        punctuators ".?!"</notes>
                </task>
                <task>
                    <desc>Clean up format of the different clauses</desc>
                    <notes>DESCRIPTION [CHECK DOES]
                        ENTERED
                        EXIT [CHECK DOES END]
                        START &lt;where&gt; '.' &lt;statements&gt;
                        
                        Any better structure? Optional END for DESCRIPTION, ENTERED etc?
                        
                        Maybe:
                        START &lt;where&gt; (DOES &lt;statements&gt; | '.' )</notes>
                </task>
                <task>
                    <desc>Image align and scaling options</desc>
                    <notes>glk_image_show() has an align parameter?
                        glk_image_show_scaled() could be used to scale acording to screen resolution?
                    </notes>
                </task>
                <task>
                    <desc>Unify multiple pronoun matches with multiple adj/noun matches</desc>
                    <notes>Both should actually say:
                        I don't know what you mean by '$1', the $1, $1 or $1.
                        
                        Actually multiple pronoun matches is not detected....</notes>
                </task>
                <task>
                    <desc>Spelling correction in interpreter?</desc>
                    <notes>Need: 'word'? I don't know that word. Do you mean 'another' y/n ?
                        
                        Design: when finding an unknown word we find the least distant word and ask player? If yes replace word in input and continue parsing, else abort as currently.
                        
                        Possibly we need to be able to turn this off on the authors discretion since some might not like their secret words to be revealed.
                        
                        http://en.wikipedia.org/wiki/Levenshtein_distance</notes>
                </task>
                <task>
                    <desc>Add header slot and structure for the SCOPE structure</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Disambiguation using checks</desc>
                    <notes>Example:
                        
                        There is water in the lake. You are carrying a bottle of water.
                        &gt; drink water
                        I don't know which water you mean.
                        
                        This should be done in parse.c but at the position where we want to do this we don't have enough information to run possible(). Surrounded it by ifdefs DISAMBIGUATE_USING_CHECKS</notes>
                </task>
                <task>
                    <desc>Word completion using TAB in the interpreters</desc>
                    <notes>Will probably need an option to turn it off to accommodate purists...</notes>
                </task>
                <task>
                    <desc>Floating point values</desc>
                    <notes>To be forward compatible we will need floating point operations and conversions as instructions. Well, not really. If any floating point instruction is added after the 3.0 set that will be ok.</notes>
                </task>
                <task>
                    <desc>Optimize game state push and pop (UNDO)</desc>
                    <notes>Currently *everything* is saved for every game turn. It would be easy to check for any changes in the parts we save (events, admin, attributes, ..) and if so only copy that. This would drastically minimize UNDO memory requirements.</notes>
                </task>
                <task>
                    <desc>Local variables</desc>
                    <notes>It would be easy to allow local variables:
                        
                        Does
                        Local x 4.
                        Set x To 7.
                        For ...
                        Local p i.
                        ...
                        End For.
                        
                        DESIGN: generate a FRAME with as many slots as there are locals. Access to local variables has to calculate frame depth, so code generation for FOR EACH has to be changed.</notes>
                </task>
                <task>
                    <desc>Looping over a string</desc>
                    <notes>There is little use for strip if you cannot loop over a string. Maybe
                        
                        For Each (Word|Character) &lt;f&gt; In &lt;string&gt;</notes>
                </task>
                <task>
                    <desc>HAVING clause on aggregate filters</desc>
                    <notes>It should be possible to filter aggregation over not only &lt;is&gt; &lt;something&gt; but also for numeric attributes, e.g
                        HAVING x = 3
                        HAVING y &gt; atr OF b</notes>
                </task>
                <task>
                    <desc>Attribute references without "of" in certain contexts?</desc>
                    <notes>It would be possible to use simple references to an attribute if the context is inside a class or instance. E.g
                        
                        The x
                        Has y,
                        Description Say y.
                        End The x.
                    </notes>
                </task>
                <task>
                    <desc>How to read the end point of a direction?</desc>
                    <notes>
                        Suggested by Andrew Duncan Heale &lt;helix@yoyo.cc.monash.edu.au&gt;
                        
                        Possibly we could have directions as some kind of instances of a class direction and then allow expressions of this type. Also a location could be a container which takes direction?</notes>
                    <task>
                        <desc>Isa DIRECTION</desc>
                        <notes>Allow ISA DIRECTION in syntax restrictions? OK, how do we then perform the natural
                            
                            SYNTAX
                            go = go (d)
                            WHERE d ISA DIRECTION
                            ...
                        </notes>
                    </task>
                </task>
                <task>
                    <desc>Free UNDO state when out of memory and retry</desc>
                    <notes/>
                </task>
                <task>
                    <desc>CHECKs as disambiguations for multiple objects</desc>
                    <notes>Could it be possible to use the CHECKs (as in the ALL handling) when disambiguating between multiple objects refered  to in a command (C.f. Lech's TAKE BOX when one is in the inventory and one on the floor).
                    </notes>
                </task>
                <task>
                    <desc>Language texts in external files</desc>
                    <notes>Need:
                        To allow user managed language translations.
                        
                        Design:
                        If an external file with the name used in the langauge option this should be used as texts for the pre-defined interpreter messages.
                        
                        Implementation:
                        1) Allow any id as a value for the language option.
                        2) Find an external language-specific message file and use it.
                        3) If the language did not have an external message file nor a entry in the pre-complied messages issue an error message.
                        
                        The format of the language file could very well be exactly as Appendix C.</notes>
                    <task>
                        <desc>How to handle special dictionary entries in unsupported languages?</desc>
                        <notes>The word types: ALL, THEM, NOISE, EXCEPT etc. are inserted by the compiler. How can we support it for a language not directly supported?
                            
                            New clause?</notes>
                    </task>
                </task>
                <task>
                    <desc>Which-form and Any-form</desc>
                    <notes>In some languages the words "which" and "any" has different forms depending on the noun. E.g in german:
                        
                        "Ich kann hier keinen/keiner/kein $1 sehen."
                        
                        To fix this we would need two new forms, one for "which" and one for "any".
                        Possibly we could have the embedded tags:
                        
                        $+&lt;n&gt; = definite form
                        $0&lt;n&gt; = indefinite form
                        $-&lt;n&gt; = none/any form (negative)
                        $?&lt;n&gt; = which form (interrogative)
                    </notes>
                </task>
                <task>
                    <desc>Also allow 'can' as attribute header words</desc>
                    <notes>So that we can do
                        
                        The gun Isa object
                        Can shoot
                        
                        The girl Isa actor
                        Can talk
                        
                        is_are_has = 'IS' | 'ARE' | 'HAS' | 'CAN'
                    </notes>
                </task>
                <task>
                    <desc>Some kind of procedures</desc>
                    <notes>NEED: to be able to execute common code without mis-using e.g events.
                        
                        ANALYSIS: we could add a new property, METHOD or ACTION or ... Which could be declared in classes and instances. It would be inherited normally, so you could "Do method Of instance." or "method:instance" or "open:door". In the last case we would probably not have methods in same namespace as verbs.
                        
                        Still to figure out how to send parameters, and to make analysis of availability of syntax parameters (complicated to investigate all invocations to verify their environment).</notes>
                    <task>
                        <desc>Functions</desc>
                        <notes>Andrew Duncan Heale &lt;helix@yoyo.cc.monash.edu.au&gt;</notes>
                    </task>
                </task>
                <task>
                    <desc>Allow locations in initial location and Locate if IN</desc>
                    <notes>This would allow collecting locations in heaps.
                        
                        Better: use IN location to mean the exits? What?!?!
                        
                        OR: defer this until arrays are available. can we have locations in Sets?</notes>
                </task>
                <task>
                    <desc>Confirmations</desc>
                    <notes>E.g. if the player says quit the game should allow the player to change his mind. (Although not if the game quit because of a false move or some such.) E.g 
                        
                        IF CONFIRM "Are you sure (Y/N) ?" THEN ...
                        
                        or even
                        
                        DEPENDING ON CONFIRM "Restore, reStart, Quit or go Back to the game (R/S/Q/B)?"
                        =1 : RESTORE.
                        =2 : RESTART.
                        =3 : QUIT.
                        END DEPEND.</notes>
                </task>
                <task>
                    <desc>Dynamic creation of instances</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Instance structures</desc>
                    <notes>Greg Ewing:
                        
                        Mike Arnaud wrote:
                        
                        &gt; And remember that ALAN makes this much easier now with classes.
                        
                        Although in cases like this, it doesn't make it as much easier
                        as it perhaps should. To do a really good door you need at least
                        two objects, or even three -- one for each side of the door and
                        one to hold the shared state of open/closed, etc. So what we
                        really want is some way of easily instantiating not just a single
                        object, but an assembly of objects with predefined relationships
                        between them.
                        
                        I've been thinking about a feature which would allow you to
                        have an object with nested object definitions within it.
                        Instantiating the outer object would then automatically
                        instantiate the inner objects as well, with some way of
                        overriding their default properties.
                        
                        Here's how you might be able to define a door using this feature:
                        
                        
                        syntax open = 'open' (obj).
                        
                        
                        every DoorSide isa Thing
                        
                        verb open does
                        if parent of obj is not open then -- Sub-objects have a built-in
                        make parent of obj open.        -- attribute 'parent' that
                        "The door is now open."         -- refers to the outer object.
                        else
                        "That door is already open."
                        end if.
                        end verb.
                        
                        end the DoorSide.
                        
                        
                        every Door isa Entity
                        
                        is open.
                        
                        the Side1 isa DoorSide  -- Every instance of Door will
                        end the Side1.          -- have its own instances of Side1
                        -- and Side2.
                        the Side2 isa DoorSide
                        end the Side2.
                        
                        end the Door.
                        
                        
                        And to instantiate a door:
                        
                        
                        the LoungeToHallwayDoor isa Door
                        
                        with Side1 at Lounge    -- When instantiating a compound
                        name 'hallway' 'door' -- object, selected attributes of
                        end Side1.              -- its sub-objects can be overridden
                        -- using a 'with' statement (or some
                        with Side2 at Hallway   -- other suitable syntax).
                        name 'lounge' 'door'
                        end Side2.
                        
                        end the LoungeToHallwayDoor.
                        
                        
                        Relevant exits would be linked to the door as follows:
                        
                        
                        the Lounge isa Location
                        ...
                        exit east to Hallway
                        check LoungeToHallwayDoor is open
                        else "The door into the hallway is closed."
                        
                        etc...
                        
                        I can see other potential uses besides doors. The program names of
                        sub-objects would be local to the parent object, so for example if
                        you have many tables in your game, you can call them all Table and
                        nest their definitions inside the relevant rooms, referring to them
                        as Table of Lounge, Table of Kitchen, etc. instead of having to give
                        them all globally-unique identifiers.
                        
                        As another example, you could define a class representing a chest
                        of drawers, including the implementations of the individual drawers,
                        and easily instantiate the whole assembly in each bedroom. The
                        possibilities are endless...
                        
                    </notes>
                </task>
            </task>
        </task>
        <task>
            <desc>Pending</desc>
            <notes/>
            <task>
                <desc>QUIT question &amp; prompt</desc>
                <notes>"Restore, reStart or Quit (R/S/Q)?" Preferably it should be possible to automatically deduce the response characters from the format (see item on CONFIRM).
                    
                    Note also that there should possibly also be a difference between the QUIT statement (to really end the game) and the QUIT player command which should/Could allow restart etc. as per the item about CONFIRMATIONS. (This should probably be done in the library.)</notes>
            </task>
            <task>
                <desc>A picture file with an unknown extension gets passed through</desc>
                <notes>E.g a.jpeg transforms into pic1.jpeg which the glk does not find. Possibly would go away if the blorb-layer was used. Investigate it.</notes>
            </task>
            <task>
                <desc>After an empty player input, the next output is not automatically capitalized.</desc>
                <notes>Did not reproduce. I wonder where I saw it...</notes>
            </task>
            <task>
                <desc>BUG: Running WinGlkArun from the prompt with wrong command line shows no message</desc>
                <notes/>
            </task>
            <task>
                <desc>Re-implement the "go" handling so that it is no longer a noise</desc>
                <notes>Can we create some kind of internal syntax for the "go (dir)" case? This could be the first step towards allowing directions as parameters.</notes>
            </task>
            <task>
                <desc>Override additively inherited properties</desc>
                <notes>Names are inherited in an additive way, is there a need for overriding NAMES from the parent? If so is this common to more properties? Which ones are inherited in an additive way?</notes>
            </task>
            <task>
                <desc>Allow Start section at an arbitrary place in the source</desc>
                <notes/>
            </task>
            <task>
                <desc>Warn if there is no When clause for every parameter in the syntax</desc>
                <notes/>
            </task>
            <task>
                <desc>Actor conversation</desc>
                <notes>A simple first step would be to recognize command format &lt;actor&gt;, &lt;command&gt; and respond with a message indicating that it is not possible to order other actors about.
                </notes>
            </task>
            <task>
                <desc>VISITS is a reserved word that causes many compiler problems</desc>
                <notes>See compiler test case visits.alan</notes>
            </task>
            <task>
                <desc>Mutual exclusive boolean attributes</desc>
                <notes>Maybe boolean attributes could be extended so they can
                    be declared in mutually-exclusive groups:
                    
                    hero attributes
                    is neuter or male or female. -- defaults to first value, i.e. neuter
                    
                    then after doing
                    
                    make hero male
                    
                    then 'hero is male' would be true and both 'hero is neuter'
                    and 'hero is female' would be false.
                    
                    This would also be useful for open/closed attributes, etc.
                    
                    the door isa object
                    is open or closed.
                    is unlocked or locked.
                    
                    Greg Ewing, Computer Science Dept, +--------------------------------------+
                </notes>
                <task>
                    <desc>Ability to declare that an attribute is the reversal of another attribute</desc>
                    <notes>It could be useful to have a way of declaring that things like "open"
                        and "closed" refer to the same attribute with opposite senses, e.g.
                        
                        OBJECT ATTRIBUTES
                        IS open ELSE closed.
                        
                        Then "front_door IS open" and "front_door IS NOT closed" would be
                        equivalent, as would "MAKE front_door open" and "MAKE front_door not
                        closed", etc. etc.
                        
                        Greg Ewing, Computer Science Dept, +--------------------------------------+
                        University of Canterbury,    | A citizen of NewZealandCorp, a   |
                        Christchurch, New Zealand    | wholly-owned subsidiary of USA Inc.  |
                        greg@cosc.canterbury.ac.nz    +--------------------------------------+</notes>
                </task>
                <task>
                    <desc>Allow definition of constants</desc>
                    <notes>Constant
                        NEUTER = 0.
                        BOY = 1.
                        GIRL = 2.
                        
                        The hero Isa actor
                        sex NEUTER.</notes>
                </task>
            </task>
            <task>
                <desc>Refactor? Allow only WHT_ID?</desc>
                <notes>If we use WHT_ID only we can use "object" as the predefined parameter name in default syntax. This makes it impossible to use OBJECT in verbs with defined syntax.
                    
                    How about WHT_LOC, &amp; WHT_ACT?</notes>
            </task>
            <task>
                <desc>Refactor UNDO? and SCORE to be FUNCTION_SYMBOLS</desc>
                <notes>Add a FUNCTION_SYMBOL to the symbol table.
                    Look up all WHAT_ID expressions and transform them into function_expressions with function code instead.</notes>
            </task>
            <task>
                <desc>Refactor: change "newxyz(&amp;srcp, " to just "newxyz(srcp, " for all xyz?</desc>
                <notes/>
            </task>
            <task>
                <desc>Allow 'A' as well as 'An' in Say statement</desc>
                <notes>Both 'a' and 'an' should be allowed in Say statement. However 'a' is commonly an identifier? Introducing it as a keyword/id introduces grammar conflicts. Investigate!</notes>
            </task>
            <task>
                <desc>Meta-output should be in []</desc>
                <notes/>
            </task>
            <task>
                <desc>CHECKs on containers</desc>
                <notes>Checks on containers to augment limits, e.g if a chest is closed we could put that test in the container check instead of the verb check?</notes>
            </task>
            <task>
                <desc>New execution model</desc>
                <notes>If we use addresses as the primary addressing mechanism we could more easily support new attribute reference format.
                    
                    E.g. 
                    
                    instance 4   -- push address to instance 4:s admin data
                    attribute 5 -- lookup its 5-attribute and push its address
                    instance 3
                    location  -- get location field
                    write -- write the top value of the stack to the address beneath
                    
                    However this does not go well with separated data since that is not adressed by Amachine addresses.</notes>
            </task>
            <task>
                <desc>Allow multiple parameter references in a WHEN clause in a Verb body</desc>
                <notes>Why? What is the problem?</notes>
            </task>
            <task>
                <desc>Separate release &amp; distribution in top level Makefile</desc>
                <notes/>
            </task>
            <task>
                <desc>Allow reverse noun/adjective order</desc>
                <notes>Need:
                    To allow latin type of langauges. "molin rouge"
                    
                    Design:
                </notes>
            </task>
            <task>
                <desc>Unnatural exit handling in winarun</desc>
                <notes>After the game has exited it is not possible to access the menus although they are visible.
                    A status variable could instead be used to indicate if a game is in progress or not. It should be possible to quit a game and then open another game to play or restart it.
                    This seems to be a limitation in the way GLK does it. Or rather the way terminate() hands over t glk_exit() after confirmation.
                    Perhaps this is not a great problem.</notes>
            </task>
            <task>
                <desc>Compile command version of interpreter with mingw</desc>
                <notes>It is possible if not using TERMIO, but how do we then present status line?</notes>
            </task>
            <task>
                <desc>Author modifiable prompt</desc>
                <notes/>
            </task>
            <task>
                <desc>Possibility for author to specify content (or lack of) status line</desc>
                <notes/>
            </task>
            <task>
                <desc>Tips about debugging in the docs</desc>
                <notes>Use Marnie's (?) example of rules executing many times and resetting the script for an actor.
                </notes>
            </task>
            <task>
                <desc>Multiple warnings for redefined verbs</desc>
                <notes>Verb x, y, x
                    ...
                    
                    Verb x
                    
                    Will generate two errors at the second "Verb x" when one would suffice.
                </notes>
            </task>
            <task>
                <desc>Document how it all fits together</desc>
                <notes>A chapter describing the overall structure of a adventure execution and how that relates to the various Alan elements:
                    
                    First the player is shown an intro text (this is the start section). Then he sees a room name and a room description (this is the instance of a sub-class of location) etc. etc.</notes>
            </task>
            <task>
                <desc>Can't assign to loop variable</desc>
                <notes>Check and error message? This is not possible with the current syntax anyway...</notes>
            </task>
            <task>
                <desc>Refactor? Make Props a field in Class and Instance instead of a dynamically allocated node</desc>
                <notes/>
            </task>
            <task>
                <desc>Document how to produce a SCRIPT-file</desc>
                <notes/>
            </task>
            <task>
                <desc>Menu entry for debugging (only available when option is turned on)</desc>
                <notes/>
            </task>
            <task>
                <desc>Warn for non-existing include directories</desc>
                <notes/>
            </task>
            <task>
                <desc>Allow expressions between two strings as SAY</desc>
                <notes>
                    E.g.
                    
                    "I have" capacity Of bottle "left."
                    
                </notes>
            </task>
            <task>
                <desc>Restrictions may make erroneous warning for multiply executed verb bodies</desc>
                <notes>If a syntax has more than one parameter and one is restricted to classes to which the verb body does not apply, the body will not be executed more than once:
                    
                    Syntax x = x (p1) (p2) Where p1 Isa literal And p2 Isa object ...
                    
                    Add To Every object
                    Verb x ...</notes>
            </task>
            <task>
                <desc>Unknown words in player input to create strings</desc>
                <notes>
                    Experiment with making unknown words into strings:
                    
                    &gt; say hello to the guard
                    
                    would automagically translate to
                    
                    &gt; say "hello" to the guard
                    
                    if "hello" is an unknown word. This could possibly be made automatically by the interpreter when encountering an (or a series of ) unknown word. Problem is probably how to error handle.</notes>
            </task>
            <task>
                <desc>Parameter environment classing</desc>
                <notes>The analysis of every statement should have a list of available parameters and their classes. Using these you can analyse classing even inside IF statements:
                    
                    IF p ISA object THEN
                    -- here we know that p has the class object
                    ELSE
                    -- here p has the same class as before IF
                    END IF.
                    
                    Furthermore you can in the IF expression verify that the parameter is a subclass to the class p has before the IF statement.</notes>
            </task>
            <task>
                <desc>Unit tests for word-handling</desc>
                <notes/>
            </task>
            <task>
                <desc>"START &lt;actor&gt; &lt;script&gt;" as alternativ to "USE &lt;script&gt; FOR &lt;actor&gt;"</desc>
                <notes>START &lt;actor&gt; &lt;script&gt;.  E.g.
                    
                    Start george cleaning.
                    Start tiger hunting.
                    
                    (This caused grammar conflicts at three points, since it is impossible to know if to reduce constructs with no 'END' on a 'START' (as if the start section was next) or if to shift it (as if a START &lt;actor&gt; &lt;script&gt; was next)
                    
                    To fix this better conflict resolutions must be made in the grammar. Conflicts was in MESSAGE, WHERE and WHEN without END WHEN. since they all have lists of statements that are not terminated.
                </notes>
            </task>
            <task>
                <desc>Reference to local attributes without prefixing</desc>
                <notes>E.g
                    
                    The i
                    Has a.
                    ...
                    Set a To 4.
                    End The i.
                    
                    
                    Instead of
                    
                    Set a Of i To 4.
                    
                    which seems a bit superflous.
                </notes>
            </task>
            <task>
                <desc>Restricted multiple object references</desc>
                <notes>Investigate the possibility to allow:
                    
                    &gt; TAKE ALL green chairs
                    
                    This implies 1) a notion of plural nouns (in english generally 's' and 2) new built in multiple reference algorithm. Plurals won't be a problem if replaced by
                    
                    &gt; TAKE EVERY green chair
                    &gt; PUSH EVERY button
                </notes>
            </task>
            <task>
                <desc>END [THE|EVERY] ID</desc>
                <notes>Make it possible to have THE and EVERY optional in END clauses.
                    
                    But not both THE and the ID...</notes>
            </task>
            <task>
                <desc>Lists of case clauses in DEPENDING ON</desc>
                <notes>
                    Allow lists of right hand expressions in the DEPENDING ON case clauses:
                    
                    DEPENDING ON x
                    =1, =3 : ...
                </notes>
            </task>
            <task>
                <desc>SCHEDULE &lt;event&gt; &lt;where&gt; WHEN &lt;expr&gt;</desc>
                <notes/>
            </task>
            <task>
                <desc>Plural handling</desc>
                <notes>What do we need it for again? Possibly "take all balls"
                    
                    Possibly could be a new clause so objects would have:
                    
                    DEFINITE
                    "the ball"
                    
                    INDEFINITE
                    "a ball"
                    
                    PLURAL
                    "balls"
                    
                    Compare http://www.firthworks.com/roger/informfaq/oo.html#11</notes>
            </task>
            <task>
                <desc>Background statement</desc>
                <notes>
                    To display a background picture (where appropriate) I like the Zork Zero thing...</notes>
            </task>
            <task>
                <desc>Optional syntax parts</desc>
                <notes>SYNTAX
                    look_up = 'look' 'up' (str) ['in' (lexikon)]
                    
                    i.e. optional parts of a syntax which can be given default parameters.
                </notes>
            </task>
            <task>
                <desc>Space bar in &lt;more&gt;</desc>
                <notes>Already works in winarun (GLK)</notes>
            </task>
            <task>
                <desc>Listing of saved games</desc>
                <notes>Already available in most GLK-versions</notes>
            </task>
            <task>
                <desc>Try UNIX/MingW as target OS for toolmaker</desc>
                <notes/>
            </task>
            <task>
                <desc>EMPTY &lt;location&gt; &lt;where&gt;</desc>
                <notes>
                    Or possibly LOCATE ALL &lt;condition&gt; &lt;where&gt;
                    
                    This was prompted by the darkness and light example, the problem being that objects at the location are described by the implicit LOOK performed when locating the hero there.
                    
                    Possibly is nullified if DESCRIPTION CHECK is introduced.
                    
                    The For Each construct with IN &lt;container&gt; or AT &lt;location&gt; can be used to move everything out of the container.</notes>
            </task>
            <task>
                <desc>Verify $&lt;n&gt; w.r.t the syntax parameters</desc>
                <notes/>
            </task>
            <task>
                <desc>Depending On with aggregates</desc>
                <notes>
                    and other variants (other than the standard binary operator)</notes>
            </task>
            <task>
                <desc>Prohibit recursive LOOK</desc>
                <notes>
                    Check for 'locate hero'/'look' in DESCRIPTIONS (to prohibit "recursive look")</notes>
            </task>
            <task>
                <desc>Darkness and Audible</desc>
                <notes>
                    How to handle darkness and other global requirements on e.g. the  location descriptions? This could possibly be handled by aspects of the descriptions, e.g. VISUAL DESCRIPTION, AUDIAL DESCRIPTION. These could be turned on/off using something like VISUAL ON. This would do away with the ever present test in the descriptions of dark locations.
                </notes>
            </task>
            <task>
                <desc>New Expression: ALL &lt;expr&gt;</desc>
                <notes>Extend &lt;what&gt; to be also
                    
                    "ALL" [ &lt;condition&gt; { "AND" &lt;condition&gt; } ]
                    
                    which would allow:
                    
                    LOCATE ALL HERE AT cave.
                    MAKE ALL OBJECT WITH size &gt; 3 heavy.
                    SET state OF ALL creature HERE AND IS hungry TO 0.</notes>
            </task>
            <task>
                <desc>EXIT out TO RETURN ....</desc>
                <notes>Could be more needed with inherited exits...
                    
                    Should probably be
                    
                    Exit out To this.
                    
                    Only requires expression instead of ID in grammar.
                </notes>
            </task>
            <task>
                <desc>EXIT ELSE ...</desc>
                <notes>Would be nice when exits are inherited. An author could then customize the "You can't go that way."
                    
                    But isn't that awailable in the MESSAGES section?</notes>
            </task>
            <task>
                <desc>Allow syntaxes that start with an object</desc>
                <notes>In german (from sturmkoening2k):
                    
                    fallenlassen = (obj) * fallenlassen
                    
                    Hmm, it's not a great deal to use:
                    lasse_fallen = lasse (obj) * fallen
                </notes>
            </task>
            <task>
                <desc>SCORE &amp; MAXSCORE as variables</desc>
                <notes/>
            </task>
            <task>
                <desc>Continued player input dialogue</desc>
                <notes>&gt; THE BALL
                    What do you want to do with the ball?
                    &gt; KICK IT
                </notes>
            </task>
            <task>
                <desc>SCENERY word, word, word</desc>
                <notes/>
            </task>
            <task>
                <desc>METAVERB, takes no tick</desc>
                <notes/>
            </task>
            <task>
                <desc>Exit directions in the status bar</desc>
                <notes>Suggested in a mail from sturmkoenig2k@t-online.de</notes>
            </task>
            <task>
                <desc>Refactor: Make compiler node types be pointers?</desc>
                <notes>make the types be pointers instead of nodes ("ClassNodePtr cla" instead of "ClassNode *cla")?</notes>
            </task>
            <task>
                <desc>xglk library problem</desc>
                <notes>Report to Zarf about the || -&gt; &amp;&amp; problem and the inconsistency on resource files (Windows look them up using extension, xglk assumes no extension). Does blorb manage them with numbers only? Yes. So that is more portable.</notes>
            </task>
            <task>
                <desc>Report mingw startup problem</desc>
                <notes/>
            </task>
            <task>
                <desc>Look into Hollywood murder screen shot of image and &lt;more&gt;</desc>
                <notes/>
            </task>
            <task>
                <desc>'again' verb</desc>
                <notes>Requires meta-handling like 'undo'</notes>
            </task>
            <task>
                <desc>Add PowerUpdater</desc>
                <notes>Really? Or create own update script on Thoni IIS?</notes>
            </task>
        </task>
        <task>
            <desc>AlanIDE</desc>
            <notes/>
            <task>
                <desc>AlanIDE v0.0.4</desc>
                <notes/>
                <task>
                    <desc>Splash screen</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Honour import path and debug preferences</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>AlanIDE v0.0.5</desc>
                <notes/>
                <task>
                    <desc>Strings spanning multiple lines does not color correctly</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Syntax Coloring preferences</desc>
                    <notes/>
                    <task>
                        <desc>Resetting coloring to default should make use of default colors when restarted</desc>
                        <notes>Seems to be caused by the preference store being empty unless explicitly set.  Possibly this is caused by the editor configuration doing its thing before the store is set up.</notes>
                    </task>
                    <task>
                        <desc>Syntax Coloring preference change should notify editor to update</desc>
                        <notes/>
                    </task>
                </task>
            </task>
            <task>
                <desc>AlanIDE v0.0.6</desc>
                <notes/>
                <task>
                    <desc>Completion for keywords</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Automatic update</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Compiler preference problems sometimes prohibit compilation</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>AlanIDE v0.0.8</desc>
                <notes/>
                <task>
                    <desc>Feature based product/application to allow net-updates</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Format source action</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>AlanIDE v.0.0.9</desc>
                <notes/>
                <task>
                    <desc>New Class wizard</desc>
                    <notes/>
                </task>
                <task>
                    <desc>New Instance wizard</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Add converter feature</desc>
                    <notes>Need:
                        Load a v2 source file, trigger "Convert from v2" on some menu, reload output into editor
                        
                        Design:
                        Require a converter preference setting.</notes>
                </task>
                <task>
                    <desc>Update java-grammar with latest syntax</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Bug: Errors in files imported but not in project are not shown anywhere</desc>
                    <notes>This can cause a user to think that the compilation was successful. Cheapest solution is to remove the .a3c-file at least. Should really mark main file if no resource with the file name was found.</notes>
                </task>
                <task>
                    <desc>Only rebuild AST for changed portions of the tree</desc>
                    <notes/>
                    <task>
                        <desc>Introduce ModelUpdater</desc>
                        <notes>A ModelUpdater should be attached to the Document of the Editor and update the Editors model when the Document changes. It needs to implement ITreeContentProvider to be able to be connected to the Outline view.</notes>
                    </task>
                </task>
                <task>
                    <desc>Incremental compilation</desc>
                    <notes>Compile with the java parser to build ast and produce syntax error messages. When that is OK, run the alan compiler to generate the game. This should be done all the time, not only at save.</notes>
                </task>
                <task>
                    <desc>Add relative option to library path</desc>
                    <notes>The compiler is run with the project as its working directory. This constitutes a problem if the the library preference is not an absolute path. When set it is validated w.r.t. the AlanIDE install directory, so when the compiler is run a relative path will not point correctly.
                        
                        An option to set relative path that is not verified (just a string?) can be a solution. See mail traffic on alan-if</notes>
                </task>
                <task>
                    <desc>Decorate resource icons and editor tabs with compilation status</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Add "New Alan Source file" to menu</desc>
                    <notes/>
                </task>
                <task>
                    <desc>"Add import"</desc>
                    <notes>Automatically declare an import for a file. Consider the import path when generating the file name in the import statement.</notes>
                </task>
                <task>
                    <desc>Navigate from outline import to imported file following import paths</desc>
                    <notes/>
                </task>
                <task>
                    <desc>New import icons in outline (use eclipse/java, where to find?)</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Pending</desc>
                <notes/>
                <task>
                    <desc>Build dependency structure for imports</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Prompt to save dependent source files also at save</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Outline view should combine multiple items into one if sequential</desc>
                    <notes>E.g.
                        Syntax a = ...
                        Syntax b = ....
                        
                        will generate four nodes:
                        
                        S
                        a
                        S
                        b
                        
                        better would be:
                        
                        S
                        a
                        b</notes>
                </task>
                <task>
                    <desc>Select project location in wizard</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Icons in png-format</desc>
                    <notes/>
                </task>
            </task>
        </task>
        <task>
            <desc>Strategies</desc>
            <notes/>
            <task>
                <desc>Containers</desc>
                <notes>
                    Containers are only properties of instances (possibly inherited of course).
                    
                    Restrictions must allow "Isa container"
                    
                    No "pure" containers.
                    
                    You can not define a class "container" as that would shadow the built in handling of restrictions "Isa container".
                    
                </notes>
            </task>
            <task>
                <desc>Thoughts about locations and surroundings</desc>
                <notes>
                    START AT et.al "location" requiring statments/expressions do really only need the SURROUNDINGS slot (not necessarily inheritance from LOCATION), but is this wise? inheritance from "location" is easy to  understand and also makes DESCRIPTION and NAME have only one meaning since instances can not be both traversible and tangible.</notes>
            </task>
            <task>
                <desc>Location Names and Mentioned</desc>
                <notes>
                    Single inheritance and the fact that location, object and actor are predefined classes is used  to restrict the generality. So an instance can not be a traversible location and a tangible object at the same time.
                    
                    A location will execute its "mentioned" as the Entry label. So any Mentioned clause will overwrite the Names clause. (Warn for this)
                    
                    An object will have "mentioned" as the SAY statements.
                    
                    Actors and object will generate a "mentioned" from the first NAME clause. If non exists the identifier will be used.
                    
                    Mentioned will be used in LISTs, and when no DESCRIPTION exist.
                    
                </notes>
            </task>
            <task>
                <desc>SAY Location = NAMES but SAY Object = Mentioned</desc>
                <notes>
                    How should the interpreter handle this difference?
                    
                    The Mentioned code slot will be used for both locations and objects.
                    
                </notes>
            </task>
            <task>
                <desc>Articles</desc>
                <notes>
                    V2 article was only indefinite, because that was what was mostly needed. But to cater for various forms of money, water, etc. both definite and indefinite is needed.
                    
                    E.g.
                    
                    SAY THE o.
                    
                    SAY A o.
                    
                    to use the two articles. And 'o' could Mention o.
                    
                    
                    PROBLEM: which form will MENTIONED then be in? Or should DEFINITE and INDEFINITE specify the whole form?
                    
                    This will mean e.g.
                    
                    DEFINITE "the money"
                    INDEFINITE "some money"
                    
                    and MENTIONED should be removed?</notes>
            </task>
            <task>
                <desc>Attributes</desc>
                <notes>
                    The attributes will have unique numbers so that the same number will be used whereever in the hierarchy it is.
                    
                    The interpreter attribute tables will have this code in them (as opposed to v2.x)
                </notes>
            </task>
            <task>
                <desc>Scripts</desc>
                <notes>
                    Scripts are analyze within the classes and instances that they are declared but not generated there. They are instead numbered uniquely and generated in a global list.
                    
                    Look up is performed by traversing the inheritance tree.
                    
                    This strategy makes it possible to use the same script code for all instances that inherit the same script.</notes>
            </task>
        </task>
        <task>
            <desc>Obsolete</desc>
            <notes/>
            <task>
                <desc>Redefinition of base classes</desc>
                <notes/>
            </task>
            <task>
                <desc>Maybe allow "Has neighbour Any object."</desc>
                <notes/>
            </task>
            <task>
                <desc>"no instance" constant ("nothing"?)</desc>
                <notes>What happens if we use that as an initialization? Which type will the attribute get?
                    
                    A better solution would be:
                    
                    Has No &lt;class&gt;.
                    
                    But still what happens if there is no value? It is better and simpler to ensure that it always points to something. This will never fail, but &lt;no value&gt; will require author controls which we must assume are not always done.
                    
                    So this is a bad idea!!</notes>
            </task>
            <task>
                <desc>Global CHECK?</desc>
                <notes>
                    What is this for?
                </notes>
            </task>
            <task>
                <desc>Mapping from old syntax</desc>
                <notes>
                    Not needed!
                </notes>
            </task>
            <task>
                <desc>allow .ACD/.DAT as well as .acd/.dat</desc>
                <notes>
                    MAC (or general?) this also goes for the names of save files, should be converted to lower case always</notes>
            </task>
        </task>
        <task>
            <desc>DONE</desc>
            <notes/>
            <task>
                <desc>Version 3.0alpha7</desc>
                <notes/>
                <task>
                    <desc>"undo" as a response to "quit?" undoes wrong command</desc>
                    <notes>If the last command did not change any state, the undo logic will find the most recent one that did, which might be very wrong. From "tv time":
                        
                        &gt; cut box
                        ...
                        &gt;...
                        &gt; move tv
                        quit? undo
                        'cut box' undone.
                        
                        
                        Analysis:
                        This can not be fixed since we don't know the difference between a quit command executed by the player to actually quit and the quit executed by the game as a fail. Pending the FAIL command planned for 3.1
                        
                        The fail-code should investigate to see if the last command did change some state and only execute undo() if it did, else return to the game.
                        
                        As a stop gap this could be done by the quit code. In case of a player quit the undo would just mean "return to game".</notes>
                </task>
                <task>
                    <desc>Does verbs in outer nested locations get executed?</desc>
                    <notes>No they don't!
                        
                        E.g.
                        
                        The l1 Isa location
                        Verb x
                        End The l1.
                        
                        The l2 Isa location At l1
                        Verb x
                        End The l2.
                        
                        The verbs should be executed in the same way as for parameters, so just traverse, find verbs and add them to the list.
                        
                        Note: also follow inheritance for all nested locations.
                        
                        Need to document the order.</notes>
                </task>
                <task>
                    <desc>Locating actors in containers should be prohibited</desc>
                    <notes>See compiler/testing/actorInContainer which produces error message for the initial location but not for the Locate statement.
                    </notes>
                </task>
                <task>
                    <desc>Aggregations over things in restricted containers does not take class restriction into consideration (e.g when finding attributes)</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Update standard library</desc>
                    <notes>Desciption in Things
                        
                        Tasks:
                        - upload and announce</notes>
                </task>
                <task>
                    <desc>An Isa object expression or loop filter should only look up classes</desc>
                    <notes>This is a problem in verbs with default syntax where the parameters have the same name as its class (object).</notes>
                </task>
                <task>
                    <desc>Ensure that "In &lt;set/container&gt;" is a class restricting filter in loops</desc>
                    <notes>This caused code within the loop not to allow e.g. access to attributes of the specified class.</notes>
                </task>
                <task>
                    <desc>Restore from a null fileref</desc>
                    <notes>When you restore and the suggested filename does not exist we get the null fileref back. Should be checked and a message given.</notes>
                </task>
                <task>
                    <desc>The Multiple-indicator for a verb word is used from the first encountered syntax</desc>
                    <notes>E.g.
                        put = put (o)*
                        put_in = put (o) in (c)
                        
                        makes put generally multiple, but
                        
                        put = put (o)
                        put_in = put (o)* in (c)
                        
                        makes it not accepting multiple.
                        
                        Verify this. Also check if it applies to omnipotent indicator to? If theory is correct, it should.
                        
                        Must be fixed so that it is the syntax that stores the flags. Can this be done without changing game format?
                        Or possibly that the compiler checks that the indicators match for all syntax synonyms.
                    </notes>
                </task>
                <task>
                    <desc>Allocate the playerWords[] dynamically</desc>
                    <notes>Use a EXTENT and ENSURESPACEFOR() somewhere in scan()</notes>
                </task>
                <task>
                    <desc>Remove MWERKS support</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Modify interpreter Makefiles to separate pieces for each executable</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Scanner tables for various non-'ISO' platforms does not seem to get generated correctly</desc>
                    <notes>Probably because the library file does not exist since the IMP does not work with Cygwin paths</notes>
                </task>
                <task>
                    <desc>Add a command line option to REGR to not overwrite passing testnames</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Version 3.0alpha6</desc>
                <notes/>
                <task>
                    <desc>UNDO problems</desc>
                    <notes>Anssi reported that
                        
                        - undo directly after restart crashes
                        - undo cancels all events
                    </notes>
                </task>
                <task>
                    <desc>Ensure that checksum calculation is done in the same way as the generating compiler did</desc>
                    <notes>Running a pre-alpha5 game with Alpha5 always generates a checksum error since Alpha5 header has grown.
                        
                        So if game version is pre-Alpha5 the checksum should be calculated with a pre-Alpha5 header length.</notes>
                </task>
                <task>
                    <desc>Ensure that there are no extra words when undo is used</desc>
                    <notes>'undo trinket' triggers undo, it should give an error message</notes>
                </task>
                <task>
                    <desc>Nested location are not described in the manual?</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Add To Every xyz &lt;attributes&gt;</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Literals handling in the interpreter</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Redeclaration of The Hero</desc>
                    <notes>
                        So he can be made to have the container property, or should we have a new kind of clause:
                        
                        Add To The Hero
                        
                        No! The hero should be possible to redeclare. But it should be possible to add features to classes:
                        
                        Add To Every object ...</notes>
                </task>
                <task>
                    <desc>The hero as a container</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Version 3.0alpha5</desc>
                <notes/>
                <task>
                    <desc>Library: open bodies says "Can't"</desc>
                    <notes>Probably
                        Add To Every object
                        Verb open_with
                        When obj1
                        Check obj2 In hero
                        Else "You don't have" Say The obj2. "."
                        Does
                        "You can't open" Say The obj1. "with" Say The obj2. "."
                        End Verb.
                        End Add To.
                        
                        Should actually be an "AND obj1 Is openable"</notes>
                </task>
                <task>
                    <desc>Nested locations</desc>
                    <notes>Done. But needs documentation update!! Prohibited to create recursive location structures, complier checks and generates run-time error!</notes>
                </task>
                <task>
                    <desc>Compile time check for recursive "location in location"</desc>
                    <notes>In compiler, or in interpreter?</notes>
                </task>
                <task>
                    <desc>Generate IFID for the game</desc>
                    <notes>Generate a type 4 (completely random) UUID and place it in a separate file, if does not exists, else it is read. The IFID is put in the game.
                        
                        Verify that the content of the ifid-file is a valid UUID.</notes>
                </task>
                <task>
                    <desc>ISA expressions should allow attribute expressions as left hand side</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Allow more general expression in 'Locate At', e.g. Random In</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Rules should be run also after initial locate to the start location</desc>
                    <notes>regression/outdoorItems should display the items at the first look.</notes>
                </task>
                <task>
                    <desc>Bug: crash on inherited added reference attribute</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Pronoun matching multiple parameters should give an error message</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Run-time check for recursive locations</desc>
                    <notes>Do this when locating an instance.</notes>
                </task>
                <task>
                    <desc>Bug: Container '.' causes problems</desc>
                    <notes>See bugs/containerdot</notes>
                </task>
                <task>
                    <desc>Renaming the WinArun to a game name seems to generate a GPF when saving</desc>
                    <notes>Michael Zerbo reported this in a mail 2006-10-01</notes>
                </task>
                <task>
                    <desc>Bug: negative constants sometimes cause SYSTEM ERROR: generating too large constant</desc>
                    <notes>bugs/2084/2084.alan exhibits this problem.</notes>
                </task>
                <task>
                    <desc>Dump Container Extract Checks and Statements</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Bug: positioning of import statements are wrong</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0alpha4</desc>
                <notes/>
                <task>
                    <desc>Locations should not be in scope</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Ensure CANCEL &lt;what&gt; works</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0alpha3</desc>
                <notes/>
                <task>
                    <desc>Multiple parameters in a position which is not the last does not work</desc>
                    <notes/>
                </task>
                <task>
                    <desc>RESTART must clear the input buffer</desc>
                    <notes>If you enter
                        
                        &gt; quit. n.
                        
                        It will quit and then continue with "n." as the next input, which will be the first after a RESTART.</notes>
                </task>
                <task>
                    <desc>It should not be possible to have multiple multiple parameter positions</desc>
                    <notes>I.e.
                        
                        v = v (a)* (b)*
                        
                        should not be allowed.</notes>
                </task>
                <task>
                    <desc>Make alpha interpreters warn for "newer" games</desc>
                    <notes>Beta may introduce incompatible changes, so we want to be able to have earlier interpreters warn the player for this,</notes>
                </task>
                <task>
                    <desc>WinArun does not set window title to game name when starting the interpreter and selecting the game in the selector</desc>
                    <notes/>
                </task>
                <task>
                    <desc>New names of packages and readme.&lt;os&gt;-files</desc>
                    <notes>Use the naming from the website in the Makefiles
                        Add readme.alan.&lt;os&gt;</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0alpha2</desc>
                <notes/>
                <task>
                    <desc>Make attribute of reference attribute does not work when inherited</desc>
                    <notes>See regression/otherside</notes>
                </task>
                <task>
                    <desc>If an opaque container contains an instance that is matched by ALL handling it is should no be actioned upon</desc>
                    <notes>Verify this theory.
                        
                        Probably a missing accessible() somewhere.</notes>
                </task>
                <task>
                    <desc>Use Script should not require an actor reference if inside an Actor class</desc>
                    <notes>Currently it does</notes>
                </task>
                <task>
                    <desc>Position calculation for -ide does not seem to be right</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Steve G's linux porting issues</desc>
                    <notes>------------------------------------------------------
                        alan
                        ----
                        
                        changed Makefile.unix
                        uncommented the -DSTDIONCONSTANT
                        took out 'unit' stuff
                        and 'test' from end of 'alan' line
                        
                        sysdep.h
                        added
                        #ifdef __linux__
                        #define stricmp(s1, s2) strcasecmp(s1, s2)
                        #endif
                        
                        
                        
                        ------------------------------------------------------
                        arun
                        ----
                        changed Makefile.unix:
                        added -DSTDIONCONSTANT
                        removed -DUSE_READLINE coz #defined in code for __UNIX__
                        removed 'unittest' from alan target dependancies
                        
                        sysdep.h :
                        added
                        #ifdef __linux__
                        #define stricmp(s1, s2) strcasecmp(s1, s2)
                        #endif
                        
                        term.c :
                        removed get windowsisze stuff coz ioctl incompatible
                        error was:
                        cc -g -Wall -funsigned-char -I  -DREVERSED -DPROGNAME=\"arun\"   
                        -D__unix__ -DHAVE_ANSI -DSTDIONONCONST   -c -o term.o term.c
                        term.c: In function 'getPageSize':
                        term.c:52: error: conflicting types for 'ioctl'
                        term.c:52: note: a parameter list with an ellipsis can't match an empty  
                        parameter name list declaration
                        /usr/include/sys/ioctl.h:42: error: previous declaration of 'ioctl' was  
                        here
                        make: *** [term.o] Error 1
                        
                        term.c:52 says
                        extern int ioctl();
                        
                        /usr/include/sys/ioctl.h:42
                        extern int ioctl (int __fd, unsigned long int __request, ...)  
                        __THROW;
                        
                        
                        
                        
                        
                        
                        glk arun
                        --------
                        - copied giblorb.c &amp; h and gi_dispa.c &amp;.h from glkterm dir into  
                        interpreter dir
                        
                        - in glkstart.c, put windows.h inside havewinglk's ifdef (so isn't  
                        attempted to be used for linux)
                        
                        - took winglk.c out of glksources in makefile
                    </notes>
                </task>
                <task>
                    <desc>Tors GLK issues</desc>
                    <notes>don't include windows.h in glkstart.c if you're not on windows.
                        
                        glk_window_move_cursor does not move relative,
                        so don't use "col" when calculating the location of the score.
                        
                        glk_window_move_cursor(glkStatusWin, glkWidth - strlen(line) - 1, 0);
                    </notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0alpha1</desc>
                <notes/>
                <task>
                    <desc>Initialize should inherit accumulated</desc>
                    <notes>Now it is overridden but it makes more sense to accumulate them and execute them from the general to the more specific. This way the instance does not have to know about all things that is necessary to initialize.</notes>
                </task>
                <task>
                    <desc>Debugger should use author names instead of player names</desc>
                    <notes>It does, doesn't it?</notes>
                </task>
                <task>
                    <desc>Default description for a instance should be either in definite or indefinite form.</desc>
                    <notes>Is there a problem with current defaults:
                        - There is a object here.
                        - Actor is here.
                        
                        Would "There is a actor here." be a better default?</notes>
                </task>
                <task>
                    <desc>List actors that have no description of their own in the same way as objects.</desc>
                    <notes>This includes script descriptions, i.e. an actor that has a script description should not be listed in the list but separately afterwards. But that would be automatically so, since that would be considered a description.</notes>
                </task>
                <task>
                    <desc>Refactor SEE_OBJ_xxxx and SEE_ACTOR_xxx into SEE_xxxx</desc>
                    <notes>Also use the same list for all things that do not have their own description.</notes>
                </task>
                <task>
                    <desc>Scan print strings and warn for parameter references where there are no parameters</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Use Script x For l does not work if l is a local</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Step After &lt;expression&gt;</desc>
                    <notes>Currently only allows integer</notes>
                </task>
                <task>
                    <desc>Potential problem: non-ISO sorting of dictionary</desc>
                    <notes>So don't sort it. Linear search will be sufficiently fast.</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev36</desc>
                <notes/>
                <task>
                    <desc>Start At location.</desc>
                    <notes>No check is performed in the start section that the identifier is actually an instance.</notes>
                </task>
                <task>
                    <desc>Style indicators should not be keywords but identifiers</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Printout of pronouns</desc>
                    <notes>Invent a Say and $-notation for pronouns and print them accordingly</notes>
                </task>
                <task>
                    <desc>SET statement should allow setting the value of a set</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Shortcut to play saviour in alan_setup.exe</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Verify that set attribute initialization is constant</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Assignment of set attributes to other set attributes</desc>
                    <notes>Sets must be managed like strings, dynamic allocation and deallocation? No, need only to copy members after verifying that the target size is large enough.</notes>
                </task>
                <task>
                    <desc>If x In {members},,, does not work</desc>
                    <notes>See compiler/testing/ifSetLiteral.alan</notes>
                </task>
                <task>
                    <desc>Saving does not cater for dynamically allocated sets and strings</desc>
                    <notes>or does it? We could use the knowledge stored in the initialization tables since only attributes need be saved.</notes>
                </task>
                <task>
                    <desc>Attribute initialization with an empty set should be allowed if it has a type and class from its inheritance</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Integer loop</desc>
                    <notes/>
                </task>
                <task>
                    <desc>COUNT IN integerSet does not work</desc>
                    <notes>Special case the integer set. It can not have any other filters since no filters can be applied to integers.
                        
                        The special case should involve I_SETSIZE instruction instead of AGRSTART et.al if the aggregate operate on an integer set.
                        
                        This should apply to MAX, MIN and SUM also?
                        
                        See regression/integerSetAggregation.alan
                        
                        
                        Say Max In integerSet Of instance.</notes>
                </task>
                <task>
                    <desc>Refactor error message handling in filters</desc>
                    <notes>compiler/testing/mixedFilters shows a problem in which the message says "aggregated over using 'EACH statement'", which is not true.</notes>
                </task>
                <task>
                    <desc>Allow class references in attribute declarations of classes</desc>
                    <notes>E.g.
                        Every door
                        Has otherside door.
                        End Every door.
                        
                        This would make it possible to avoid "fake" instances and instances that have incorrect values because initialization was forgotten.
                        
                        Note in the manual that a "fake" instance is a way to solve NULL-pointers, i.e a special marker indicating "no relevant value".
                        
                        If a class was allowed we could ensure that an actual instance was used by traversing the inheritance tree. An instance should not be allowed to inherit from a class with a non-instance initalization without initializing it (somewhere along the inheritance chain).
                        
                        Design tasks:
                        1) Allow class
                        2) Verify initialization
                        3) Manual</notes>
                </task>
                <task>
                    <desc>Inherited abstract reference attributes</desc>
                    <notes>The example in section on Inheriting Attributes in 4.7.4 does not work as planned. An intermediate attribute definition should be allowed and restrict it.
                        
                        See compiler/testing/lockableDoors</notes>
                </task>
                <task>
                    <desc>DIRECTLY for aggregate</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Random Directly In container</desc>
                    <notes/>
                </task>
                <task>
                    <desc>DIRECTLY At obj</desc>
                    <notes>See exe.c at() where there is some pre-processor condition that stinks</notes>
                </task>
                <task>
                    <desc>Error 225 is incorrect when IN is used since that will delimit the types of instances</desc>
                    <notes/>
                </task>
                <task>
                    <desc>There should be no space before a full stop even if the previous output was an expression.</desc>
                    <notes>"string" Say Count ... ".$p" generates an extra space. Problem is obviously the $p since without it it works ok.</notes>
                </task>
                <task>
                    <desc>Refactor out the file lists from the Makefiles</desc>
                    <notes>Move these to separate included files
                    </notes>
                </task>
                <task>
                    <desc>For Each In &lt;integerset&gt; does not work</desc>
                    <notes>Use same special case as &lt;aggregate&gt; In &lt;integerset&gt; which uses SETSIZE and SETMEMBER.</notes>
                </task>
                <task>
                    <desc>Semicolon should terminate command line to act as a comment starter</desc>
                    <notes/>
                </task>
                <task>
                    <desc>UNDO handling does not seem to manage dynamic sets</desc>
                    <notes/>
                </task>
                <task>
                    <desc>UNDO should only save state when the player changes anything</desc>
                    <notes/>
                </task>
                <task>
                    <desc>UNDO handling does not seem to manage strings</desc>
                    <notes/>
                </task>
                <task>
                    <desc>The undone-message does not work for literal values</desc>
                    <notes>See regression/undoSet</notes>
                </task>
                <task>
                    <desc>Respond to UNDO with "You undo 'x x x '."</desc>
                    <notes>This will have to include the command words in the undo state. DONE
                        Prepare M_UNDONE message with one string parameter.</notes>
                </task>
                <task>
                    <desc>Add section on scripting and commenting in the manual</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Include ! in characters that excludes an automatic space</desc>
                    <notes>Any other? like '?'</notes>
                </task>
                <task>
                    <desc>Check up the library wrt. PRONOUNs; introduce human, person, man, woman</desc>
                    <notes/>
                </task>
                <task>
                    <desc>A Set should be possible to initialize to empty by giving a class name</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Should checks only be run for alternatives that match?</desc>
                    <notes>Currently the checks are run for all alternatives.
                        
                        Verify what this would mean in a practical example.
                        
                        I think only checks for matching alternatives would be natural.
                    </notes>
                </task>
                <task>
                    <desc>WinArun does not ask for a game file if started by double-clicking on the program</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Renaming WinArun does not load game</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Fix picture in about Arun box</desc>
                    <notes>Only occurs on W2k &amp; XP</notes>
                </task>
                <task>
                    <desc>Refactor SourceFileEntry to contain two structs fpos/len</desc>
                    <notes>One for the path and one for the basename. For now just split it and use basename everywhere.</notes>
                </task>
                <task>
                    <desc>Add header entry and entry type for breakpoint list</desc>
                    <notes/>
                </task>
                <task>
                    <desc>List line numbers for which LINE instructions are generated?</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Add To Every xyz</desc>
                    <notes>Investigate what is left to do:
                        
                        
                        All below is done:
                        ----------------------------
                        It should be possible to add features to classes:
                        
                        Add To Every object ...
                        
                        Otherwise there is no way to do the same thing as V2 ATTRIBUTES.
                        
                        In v3 it should be possible to add anything that is not already available:
                        
                        attributes (DONE), scripts, exits, verbs - adds to the list, but can not redefine if already existing
                        
                        initial location, container - can only be added if it has none
                        
                        mentioned? article? description?</notes>
                    <task>
                        <desc>Add Initial Location</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Add Name</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Add Pronoun</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Add Initialize</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Add Entered</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Add Mentioned</desc>
                        <notes/>
                    </task>
                </task>
                <task>
                    <desc>Inherting all props</desc>
                    <notes>Investigate which ones are left!!!!
                        
                        DONE:
                        attributes
                        scripts
                        verbs
                    </notes>
                    <task>
                        <desc>Inherit Entered</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>MENTIONED can not be inherited</desc>
                        <notes>Since the MENTIONED is generated automatically from the NAME it can not be inherited. If this was not the case it could be inherited, but then it would be impossible to indicate to override it to use the name instead.
                            
                            This is kind of a general question, but affects the MENTIONED particularly.</notes>
                    </task>
                </task>
                <task>
                    <desc>Add NEGATIVE ARTICLE/FORM clause</desc>
                    <notes>with "Say No x." and "$-1" as print forms.
                        
                        Including Add and inherit!</notes>
                    <task>
                        <desc>Add Negative Article/Form</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Inherit Negative Article/Form</desc>
                        <notes/>
                    </task>
                </task>
                <task>
                    <desc>Bug: trailing single dollar in a string causes spurious output</desc>
                    <notes/>
                </task>
                <task>
                    <desc>M_ARTICLE can be removed since Indefinite Article on entity is exactly the same thing</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Ensure that multiple pronoun matches are handled</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev35</desc>
                <notes/>
                <task>
                    <desc>Refactor listing so that all termination produces a list with the appropiate format</desc>
                    <notes>Prompted by SYSERR not producing -cc style listing which trashed alanIDE:s message parsing</notes>
                </task>
                <task>
                    <desc>Refactor DIRECTLY to be on WHERE?</desc>
                    <notes/>
                    <task>
                        <desc>Aggregates and filters must allow DIRECTLY</desc>
                        <notes>Currently they are not transitive, but should have the same semantics as IN and AT: DIRECTLY is required to get the non-transitive evaluation</notes>
                    </task>
                    <task>
                        <desc>DIRECTLY HERE, DIRECTLY NEARBY</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>NEARBY should use non-DIRECTLY version of where()</desc>
                        <notes>Make test cases for NEARBY first</notes>
                    </task>
                </task>
                <task>
                    <desc>A container without a description should be listed automatically</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Document that $n prints using player words and Say does not.</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Restriction analysis questions</desc>
                    <notes>The current analysis of restrictions and their statements seem to start by assuming every parameter is an instance and go from there. That's ok, but at the same time the legacy indicates that the default of a parameter should be "object", and we can have these at the same time:
                        
                        Syntax x = x (a) (b)
                        Where a Isa c1
                        Else "Here b is either an entity or an object, depending on the strategy."
                        
                        Probably this should work by first working through the restrictions to see if a parameter is restricted, if not at all it should be assumed an "object" and if it was restricted (in the class dimension, not container) it should start out as an entity.
                        
                        This is not true. The legacy only indicates that the parameter should be an object in the *bodies*. The restrictions could still assume entity to begin with. Ensure that a non-restricted parameter is an object.</notes>
                </task>
                <task>
                    <desc>Allow expression in List statement.</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Text Styles</desc>
                    <notes>New statement "Style xxx." Use GLK styles:
                        - Normal
                        - Emphasis
                        - Preformatted
                        - Alert
                        - Quote</notes>
                </task>
                <task>
                    <desc>Inherited Exits</desc>
                    <notes>Usefullness?
                        
                        Yes, you could allow inherting the complete exit and just override the target location, This could make checks and does clauses inherited.</notes>
                </task>
                <task>
                    <desc>-ide switch to output messages with character positions</desc>
                    <notes>In AlanIDE it would be nice to use character positions instead of line markers.</notes>
                </task>
                <task>
                    <desc>INIT clause as property</desc>
                    <notes>An INIT clause would be very handy to initialize an instance when it is created. This would allow for much greater modularity.
                        
                        The INITIALIZE clause is executed at the start location and the current actor is hero.</notes>
                </task>
                <task>
                    <desc>Refactor: Allocate parameter lists</desc>
                    <notes>If the compiler sends the maximum number of parameters in any syntax (header-&gt;maxParameters) we can allocate only so much space for the parameter manpulation lists in the interpreters parser.</notes>
                </task>
                <task>
                    <desc>Events as attributes</desc>
                    <notes>This could be handy for storing the currently executing event in a series of events, see Ferrari example.
                        
                        Would require expressions in Cancel and Schedule statements.</notes>
                </task>
                <task>
                    <desc>PLAY statement</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Resource type management</desc>
                    <notes>The extensions of resource files (sounds and images) sometimes controls the kind of resource. Case in point: .MOD is MUS and .AIF/.AIFF is SND.
                        
                        We need a mapping which implies that we need to discover file extensions in resource file names.</notes>
                </task>
                <task>
                    <desc>Use Blorb-layer for resources</desc>
                    <notes>Lacking source for a blorb-packer, possibly in iblorb sources...</notes>
                </task>
                <task>
                    <desc>Add To Every xyz &lt;exits&gt;</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Investigate multi-class word problems</desc>
                    <notes>Word as synonym and verb
                        Word as synonym and direction
                        Word as verb and direction
                        ....
                        
                        Which of the above works, and what is the problem with each that doesn't?
                    </notes>
                    <task>
                        <desc>Word-clash</desc>
                        <notes>Multiclass word problem 3: PREPOSITION &amp; VERB
                            Words can't be prepositions and verbs at the same time. See gestx()
                            
                            New and better dictionary handling in the compiler could remedy the multiple word class problems. Or as a first step, try to find a way to point out where a 333 comes from (e.g. 'e' defined both as a synonym and as a another word class).
                        </notes>
                        <task>
                            <desc>Multiclass word problem 1: VERB &amp; DIRECTION</desc>
                            <notes>Multiclass word problem 1: VERB &amp; DIRECTION
                                The VERBDIR problem (check regression test verbdir), using the same word as both a verb and a direction does not work.
                                
                                This does not work since the first word in the player input must indicate which type of command it is.
                                
                                Document this and make the message an error? Yes.</notes>
                        </task>
                        <task>
                            <desc>Multiclass word problem 2: ADJECTIVE &amp; VERB</desc>
                            <notes>Multiclass word problem2: ADJECTIVE &amp; VERB, doesn't work because the dictionary handling in the compiler (newwrd) returns the code of the found word which is the same as the adjective, resulting in execution of the wrong (if any) verb... (See regression test adjverb) Somehow we must separate word codes from the codes used by the objects, verbs etc.
                            </notes>
                        </task>
                        <task>
                            <desc>Multiclass word problem 3: PREPOSITION &amp; VERB</desc>
                            <notes>Multiclass word problem 3: PREPOSITION &amp; VERB
                                Words can't be prepositions and verbs at the same time. See gestx()
                            </notes>
                        </task>
                    </task>
                    <task>
                        <desc>Locals should override directions</desc>
                        <notes>Currently For Each e gives an error message if the direction 'e' is already declared. Directions are not available to the programmer so should not be entered in the symbol table?</notes>
                    </task>
                </task>
                <task>
                    <desc>Refactor: move descriptionSRCP et.al into a Description Node</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Allow nearby to be applied to locations</desc>
                    <notes>See games/goto.
                        
                        Currently the interpreter crashes.</notes>
                </task>
                <task>
                    <desc>Implement &lt;what&gt; NEAR &lt;what&gt;</desc>
                    <notes>As a complement to NEARBY</notes>
                </task>
                <task>
                    <desc>Default restrictions in instances inheriting from unknown classes gives 323</desc>
                    <notes>compiler/testing/defaultRestrictionInUnknownClass.alan</notes>
                </task>
                <task>
                    <desc>Verify file type association and Windows double click</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev34</desc>
                <notes/>
                <task>
                    <desc>Multiple distant objects for omnipotent syntaxes should say "I don't know which one"</desc>
                    <notes>Currently it results in "I don't see any x here."</notes>
                </task>
                <task>
                    <desc>BUG: multiple syntaxes sometimes results in a "You must supply a noun"</desc>
                    <notes>See regression/syntaxOrder
                    </notes>
                </task>
                <task>
                    <desc>Verify that an inherited set or reference attribute retains the type</desc>
                    <notes>It should not restrict the type to the initializers type. Or should it? No, document that the complete type of an attribute is defined at the top level, i.e. the top-most declaration of an attribute will define its type.</notes>
                </task>
                <task>
                    <desc>Document attribute inheritance wrt. SET and REFERENCE</desc>
                    <notes>Infered class of referees and members, subclassing and that the original class is retained through out the hierarchy.</notes>
                </task>
                <task>
                    <desc>Inherit NAMES in an additive way</desc>
                    <notes>This would allow:
                        
                        Every fruit
                        Name fruit
                        
                        The apple Isa fruit
                        The pear Isa fruit
                        
                        &gt; take the fruit
                        
                        Possibly this would create a need for OVERRIDE NAME, or in the same way for all properties inherited additive. Which ones are that?</notes>
                </task>
                <task>
                    <desc>Make INCLUDE a grammar symbol to only allow structured includes</desc>
                    <notes>Still need to do it in the scanner though...</notes>
                </task>
                <task>
                    <desc>Auto-generated syntaxes should have a restriction</desc>
                    <notes>The restriction should match the assumed class of the parameter of course.</notes>
                </task>
                <task>
                    <desc>Inherit initial location</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Allow optional period after "Container"</desc>
                    <notes/>
                </task>
                <task>
                    <desc>List candidates which caused the ambiguity in input</desc>
                    <notes>* Although not strictly necessary, it would be nice if
                        the "I don't know which xxx you mean" message could be
                        improved to list the candidate objects, as other systems
                        do. Although it would be better to phrase it in terms
                        of a statement rather than a question, i.e.
                        
                        I don't know whether you mean the big blender, the
                        small blender or the super duper blender.
                        
                        unless you also intend to allow the question to be
                        answered.
                        
                        This would be particularly helpful in the case of
                        !-arguments, since in that case the player may have
                        no readily available means of reviewing the set of
                        possible objects and their full names, in order to
                        find an unambiguous phrasing.
                    </notes>
                </task>
                <task>
                    <desc>Clean up of pre-defined classes</desc>
                    <notes/>
                    <task>
                        <desc>Enforce inheritance</desc>
                        <notes>No instances or classes can be declared without a parent. Don't know what this would mean...</notes>
                    </task>
                    <task>
                        <desc>Entities should be available everywhere but not show up in descriptions or lists</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Sub-classes to entities must behave like entities</desc>
                        <notes>Entities don't have location properties, nor are they described automatically. Document this and warn for a location property.
                            
                            The same goes for all subclasses of entity that the player has made, or rather everything not inheriting from thing, since things are the subclass that adds location and automatic descriptions. Document this and implement it.
                            
                            "Every topic Isa entity" should give all topics the non-location, non-description feature.
                            
                            VERIFICATION: Only objects, and actors are automatically described. Things are not. But things have location?</notes>
                    </task>
                    <task>
                        <desc>Things should not show up, but only be available at their location</desc>
                        <notes/>
                    </task>
                </task>
                <task>
                    <desc>Describe "scoping rules" and interpreter scoping viz-a-viz author code</desc>
                    <notes>There are a couple of ways to get instances into player "scope".
                        
                        Interpreter finds instances and *then* calls author defined code.</notes>
                </task>
                <task>
                    <desc>RANDOM IN &lt;container&gt;</desc>
                    <notes>Randomly select one of the instances in the container
                        
                        Has type of the container TAKES</notes>
                </task>
                <task>
                    <desc>Random In &lt;set&gt;</desc>
                    <notes>Returns one value in the set.
                        
                        How to handle the empty set???? Run-time error obviously.</notes>
                </task>
                <task>
                    <desc>Container listings should not show up if it only contains things.</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Transitive AT/IN</desc>
                    <notes>Change At and In to always be transitive (where possible, "Locate x IN y" can obviously not be transitive) Introduce a modifier to AT &amp; IN, DIRECTLY which modifies the behaviour to non-transitive where appropriate.</notes>
                    <task>
                        <desc>IN &amp; AT operators</desc>
                        <notes>Change IN &amp; AT operators to both be transitive.</notes>
                    </task>
                    <task>
                        <desc>Add DIRECTLY to syntax for all WHERE expressions</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Generate code for DIRECTLY</desc>
                        <notes/>
                    </task>
                </task>
                <task>
                    <desc>Pronoun declarations</desc>
                    <notes>Need:
                        "You can not shoot at that." is not very logical when the target is a person. Neither is
                        
                        &gt; ask woman about Sally
                        "Sally, is my daughter. I haven't seen her for twenty years now. I miss her so."
                        
                        &gt; ask her about the weather
                        I can't see any Sally here.
                        
                        
                        Analysis:
                        To fix this we need a declaration of pronoun, e.g
                        
                        The woman Isa person
                        Pronoun her
                        End The woman.
                        
                        Implementation requires:
                        - grammar change
                        - run-time execution
                        - embedded string printing (only if we want to be able to use it in strings)
                        - library change
                        
                        Implementation:
                        - send number of unique pronouns to interpreter
                        - for each parameter save the instance in corresponding pronoun slot
                        - when pronoun is used in input look it up in the slot
                        
                        How to handle the above example? Probably by looking in the scope for any instances with the given pronoun.</notes>
                    <task>
                        <desc>Grammar, internal form and dump</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Analysis</desc>
                        <notes>- Not allowed on Locations
                            - Add words to dictionary</notes>
                    </task>
                    <task>
                        <desc>Generate reference lists</desc>
                        <notes>Each instance should have a list of words which can be used as pronouns for it.</notes>
                    </task>
                    <task>
                        <desc>Inherit pronouns</desc>
                        <notes>Pronouns should override. We can simply point to the definition higher in the hierarchy,</notes>
                    </task>
                    <task>
                        <desc>Add pronoun table to interpreter and update it with each parameter in the command</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>What happens if a pronoun word is the same as any other word?</desc>
                        <notes>The pronouns need to have unique numbers in sequence from zero so that an array can be used to store instance references in the corresponding "slot".
                            
                            If another word class has already entered it in the dictionary it will receive that classes code.
                            
                            Probably we want to have unique word code for every unique word, and then a code per class that needs a translation. This would probably also solve the other multi-class word problems...</notes>
                    </task>
                    <task>
                        <desc>How to handle multiple parameters?</desc>
                        <notes>The THEM_WORD is used to refer to all parameters in a previous multi command. Would this still work?</notes>
                    </task>
                    <task>
                        <desc>Change M_WHAT_IT so that it uses the pronoun word instead of it</desc>
                        <notes/>
                    </task>
                </task>
                <task>
                    <desc>Player reference to single object using 'them'</desc>
                    <notes>Refer to regression/them where a pair of sunglasses illustrates the point.</notes>
                </task>
                <task>
                    <desc>Change M_NO_SUCH so that it uses the words the player used</desc>
                    <notes>This means setting a flag so that sayParameter() knows to use the player words and not the instance names.
                    </notes>
                </task>
                <task>
                    <desc>Output names in correct case</desc>
                    <notes>Store names in dictionary in original case, compare to player input case-insensitive.</notes>
                </task>
                <task>
                    <desc>Remove special handling of actors with respect to definite/indefinite forms</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Parameter available for attribute checks in some MESSAGEs</desc>
                    <notes>Could be handy. This would require each MESSAGE-code to define the parameters available and to set up this before entering the analysis of the statements.
                        
                        This would be really good for translations. E.g in german "kein" has different forms depending on case. So the constant string "Ich kann hier kein $1 nicht sehen." is not always correct. However, if messages had parameters we could implement:
                        
                        Message CANTSEE:
                        "Ich kann hier"
                        If object Is neuter Then "keiner" End If.
                        If object Is masculine Then "kein" End If.
                        If object Is feminine Then "keine" End If.
                        Say object. "sehen."
                        
                        
                        Design:
                        
                        Messages to allow are:
                        M_WHICH_ONE_START
                        M_WHICH_ONE_COMMA
                        M_WHICH_ONE_OR
                        M_NO_SUCH
                        
                        Possibly also (when refactored)
                        M_CANT
                        M_SEEOBJ1 et al.
                        M_CONTAINS et al.
                        M_CARRIES et at.
                    </notes>
                </task>
                <task>
                    <desc>Add message handling for UNKNOWN word</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Wrong space formatting in regression inheritContainer</desc>
                    <notes>This is probably because it is an embedded symbol so after printing the symbo there is both a newline and the next character in the string is a space.
                        
                        Newline need to set needsp = FALSE and output need to adhere to it when it has printed the symbol and ignore any leading spaces in the rest of the string.
                    </notes>
                </task>
                <task>
                    <desc>Document PRONOUN</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Document new messages</desc>
                    <notes>Also note the change in the conversion appendix
                        NOTE any instance for which noun in noSuch()</notes>
                </task>
                <task>
                    <desc>Saved name of game in a save-file should not contain path</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Fix problem with OPAQUE attribute not being inherited along with container properties</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Document inheritance rules for each construct</desc>
                    <notes>Isn't it already?
                    </notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev33</desc>
                <notes/>
                <task>
                    <desc>Sets</desc>
                    <notes>Some kind of list or array datatype, like TADS lists, with
                        appropriate operations (indexing, finding its length, inserting
                        an item, deleting an item).
                        
                        (Greg Ewing in Alan-IF mailing list)
                        
                        Analysis:
                        Requires initialisation e.g Has partners [x, y]
                        Should allow loop over
                        Should have RANDOM selection
                        Reference to element partners[i] (or possibly not)
                        Have to allow add (partners + &lt;instance&gt;) and remove (partners - &lt;instance&gt;)
                        Watch out for changing array while looping
                        
                        Design:
                        
                        declaration: Has set {x, y}.
                        Empty sets are not allowed. Set gets least common denominator class if instances. Can use integers and strings too.
                        
                        add and remove:
                        Include &lt;expr&gt; in &lt;expr&gt;.
                        Remove &lt;expr&gt; from &lt;expr&gt;.
                    </notes>
                    <task>
                        <desc>Declaration of sets</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Include &lt;expr&gt; in &lt;set&gt;</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Remove &lt;expr&gt; From &lt;set&gt;</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Expression In &lt;set&gt;</desc>
                        <notes/>
                    </task>
                </task>
                <task>
                    <desc>Handle comma as period. No space before.</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Allow dash and underscore within words in player input</desc>
                    <notes/>
                </task>
                <task>
                    <desc>A very large number of events will not restore correctly after a save</desc>
                    <notes>There seems to be no check for event queue size when reading events back from a save file</notes>
                </task>
                <task>
                    <desc>For loop Filters</desc>
                    <notes>Possibly we can port the aggregate filters to the For Each loop.
                        
                        To get
                        For Each &lt;class&gt; [&lt;var&gt;] Which &lt;filter&gt; { And &lt;filter&gt; } Do
                        End For Each [&lt;var&gt;].
                        
                        
                        All below is done:
                        First (but useless) version would be
                        
                        For Each Do
                        End For Each.
                        
                        Next version would be
                        
                        For Each &lt;class&gt; Do
                        End For Each.
                        
                        Which could be extended to
                        
                        For Each &lt;class&gt; [&lt;var&gt;] Do
                        End For Each [&lt;var&gt;].
                        
                        This also implies analysis of references to &lt;var&gt; as being of &lt;class&gt;, and code generation of such references.
                    </notes>
                </task>
                <task>
                    <desc>Verify UNDO</desc>
                    <notes>Make test cases for each bit of information that is to be undone.</notes>
                </task>
                <task>
                    <desc>QUIT message should allow UNDO</desc>
                    <notes/>
                </task>
                <task>
                    <desc>UNDO needs some kind of response?</desc>
                    <notes>Generally: UNDO should say something, standard messages?
                        
                        Should we allow UNDO as a response to quit?</notes>
                </task>
                <task>
                    <desc>UNDO does not affect heros position</desc>
                    <notes>Bug? Save current state also? Why is not current.location set to heros location?
                        
                        We also need some way to re-output the state.</notes>
                </task>
                <task>
                    <desc>Change DEPEND case separator to 'THEN'</desc>
                    <notes>DEPEND does not work with identifiers in the cases
                        DEPEND On X
                        = bartender : ...
                        
                        Doesn't work any more... If it ever did...
                        
                        Change ':' to 'THEN'</notes>
                </task>
                <task>
                    <desc>Set may not contain Strings</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Empty player input to forfeit player turn</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Script Step After n does not work</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Verify converters handling of quoted ids especially for new reserved words</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev32</desc>
                <notes/>
                <task>
                    <desc>Allow expression as actor in "Use script for..."</desc>
                    <notes>Investigate Stop actor.
                        
                        Stop does not analyze its expression to be an actor.</notes>
                </task>
                <task>
                    <desc>&lt;more&gt; should work when taking commands from a file</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Add "Playback comamnds" to WinGLK menu</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Default save name in WinArun should be basename of game</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Bug: Multiple syntax verb declarations</desc>
                    <notes>The problem with multiple syntax verbs is that only the first one is actually checked in any consistent manner. Also it is not clearly defined when two syntaxes are compatible and allowed to use in the same verb declaration. At present the compiler only checks for same number of parameters and the same names. That is not enough to cover it, it should actually also create a class definition for each parameter for use in this verb which is the sum of all the class definitions of the two syntaxes for the parameter.
                        E.g.
                        Syntax a = v1 (p1) Where p1 Isa Object Or Actor ...
                        Syntax b = v1 (p1) Where p1 Isa Container ...
                        Verb a, b
                        Here a reference to p1 should be considered to be either Object, Actor or Container
                        
                        Design:
                        At analysis connect a parameter list to the verb and use that instead of the syntax
                        
                        Actually this is obsolete, since in v3 you can not do that, you can only specify one class.
                    </notes>
                </task>
                <task>
                    <desc>Multiple messages for initial locations which are not declared</desc>
                    <notes>The t Isa object In unknown ...
                        
                        results in:
                        
                        310 E : Identifier 'unkown' not defined.
                        310 E : Identifier 'unkown' not defined.
                        
                        Fix it!
                    </notes>
                </task>
                <task>
                    <desc>SAVE &amp; RESTORE texts as messages</desc>
                    <notes>Currently the library (or verb) prints "Saved. OK" even if the save was aborted (like it can be in WinArun). This should instead be a message SAVE_OK and complemented with a SAVE_ABORTED. Same for RESTORE. Possibly they could be made into one OK and ABORTED messages.
                        
                        This is handled by WinArun now.</notes>
                </task>
                <task>
                    <desc>Containers can take any type of instance, how to handle Limits?</desc>
                    <notes>Step 2:
                        
                        Design:
                        
                        New clause on containers:
                        Container
                        Takes thing  (Or: Of thing)
                        Else ....</notes>
                </task>
                <task>
                    <desc>Allow parameters as actor in USE statement</desc>
                    <notes>Need: to be able to start a specific script for a variable actor.
                        
                        Simply allow an expression as the actor in USE statement, inheritance etc. will take care of the rest ;-)</notes>
                </task>
                <task>
                    <desc>Programmer Pitch in manual</desc>
                    <notes>Alan is an application oriented language. It features constructs that are natural to an author of Interactive Fiction. Alan is a strictly typed, compiled, objectoriented language with single inheritance. Classes inherits properties from their superclasses. The class system allows polymorphism so that instances of subclasses are valid wherever a superclass is specified. There are no explicit types, instead types are inferred from the expressions.</notes>
                </task>
                <task>
                    <desc>Allow full stop/period/'.' as a sentence breaker in player commands</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Unify messages 311, 351, 410, 428</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Allow expression as What in Locate</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Allow expression as What in Where</desc>
                    <notes/>
                </task>
                <task>
                    <desc>New attribute reference syntax</desc>
                    <notes>Allow
                        l:dark
                        instead of
                        l is dark
                        and
                        o:size
                        instead of
                        size of o
                        
                        Because it could be made more general:
                        
                        The east_door
                        Isa object.
                        Has other_side west_door.
                        Has size 4.
                        End The door.
                        
                        ... If door:other_side:size &gt; 3 Then
                        
                    </notes>
                </task>
                <task>
                    <desc>The usage text for the compiler says that include directories are searched before, THATS WRONG!</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Refactor schedule to use Expression</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Remove REVERSED using the endian() function in sysdep</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev31</desc>
                <notes/>
                <task>
                    <desc>Attributes of class type</desc>
                    <notes>Attributes should be allowed to refer to other entities. This would require strict classing of them and verification of assignment of them. Such an attribute can only be changed to something a sub class of what it was initially set to. But on the other hand we must also be allowed to do:
                        
                        LIST ontop OF box.
                        
                        Or should we only allow this through use of temporary variables? If so how do we restrict it?</notes>
                    <task>
                        <desc>Instance Type in type system</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Attribute declarations of instance Type</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Code generation of instance attributes</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Expression syntax for accessing attributes of attributes</desc>
                        <notes>In order to refer to an attribute of an instance which is refered to by an attribute the expression syntax need to be changed so that it allows:
                            
                            Make otherside Of door open.
                            Set size Of bag Of thief To 4.
                            
                            Possibly at the same time we could introduce a new attribute reference syntax, e.g:
                            Make door:otherside:open.
                            Set thief:bag:size To 4.</notes>
                    </task>
                    <task>
                        <desc>Assignment rules for instance attributes</desc>
                        <notes>Requires actual value to be only subclasses of instance initial class.</notes>
                        <task>
                            <desc>Type comparison rules for instance type</desc>
                            <notes/>
                        </task>
                    </task>
                </task>
                <task>
                    <desc>Unify error messages 408, 413 and 428</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Error 223 (executed for every parameter) is shown even if there is no body</desc>
                    <notes>Checks are always run it's the bodies that we have to warn for</notes>
                </task>
                <task>
                    <desc>Bug: Spaces after $o at end of string</desc>
                    <notes>SteveG:
                        Firstly, I found that if a double-quoted string ends in $o or such like then the next string isn't followed by a space. I thought when concatenating bits of text that they were always split up by a space unless the $$ parameter was specified. The little game space.ala is attached to demonstrate what I mean.
                        
                    </notes>
                </task>
                <task>
                    <desc>Allow reading player input from file</desc>
                    <notes>A '@' as the first character will make the interpreter read the rest of the line as a file name. It tries to open that file and read lines from it one at a time, as if the player had input them.
                    </notes>
                </task>
                <task>
                    <desc>Scripting</desc>
                    <notes>It should be possible to give a command so that the interpreter can read a set of player commands from a file.
                        
                        Design: @&lt;file&gt;? Read one line at a time and feed that into readline(), on error stop, remember to close the file</notes>
                </task>
                <task>
                    <desc>Bug: Aggregates does not work</desc>
                    <notes>Should they only address objects as it says in the docs? No, probably it should have a class restriction as an optional clause and object as a default.</notes>
                </task>
                <task>
                    <desc>Add To Every xyz &lt;scripts&gt;</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Priorities of operators stink</desc>
                    <notes>Count at l = 8
                        -&gt; '=' replaced by 'OR'</notes>
                </task>
                <task>
                    <desc>RESTART does not work well in WinArun</desc>
                    <notes>Choosing RESTART from the menu restarts the game but also seems to redo the last command from the input. A glk_stream not cleared?
                        
                        Could not repeat this!</notes>
                </task>
                <task>
                    <desc>Make distinction on words and symbols and identifiers</desc>
                    <notes>The manual should have a clear description of each. In "lexical definitions"?</notes>
                </task>
                <task>
                    <desc>OSX porting feedback</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev30</desc>
                <notes/>
                <task>
                    <desc>List error messages in same order as they where generated</desc>
                    <notes>This is particularly important when syntax corrections leads to semantic errors. It is essential that they are show in that order. This change must be made in List.imp,
                        
                        Design: add a counter field in the message entries and sort on those also.</notes>
                </task>
                <task>
                    <desc>Capitalized names is a problem in parameters since printing of them use player input (Step 1)</desc>
                    <notes>E.g.
                        &gt; talk to mr x
                        
                        Does not output
                        
                        Mr X does not want to talk to you.
                        
                        This is because the 'x' is in the player input. This design was made so as to not reveal objects secret properties:
                        
                        &gt; examine rod
                        You can not examine the dynamite.
                        
                        Is it possible to do both? Current view is that a the feature with hiding names is an author responsibility. E.g he/she must program the mentioned clause to take care of this if required.
                        
                        Step 1: Don't ever use player input
                        
                        Step 2: Even better, but much harder would be to create default mentioned clauses by listing the word-numbers to show. (A words number would be the number of the lower case version of the word). Then a Say could select the words the player input but show them in the case the author wanted.</notes>
                    <task>
                        <desc>Automatic capitalizing of nouns (e.g in german) only worked for player said words</desc>
                        <notes>Now since the parameters don't use the player words this is invalidated. Probably should change strategy so that the player can input any word and the words are stored capitalized (if specified). This would possibly do away with the run-time capitalization and the impossibility for the player to input names of locations which are automatically capsed by the compiler.
                            
                            Think this through and make a design!!</notes>
                    </task>
                    <task>
                        <desc>Location names are capitalized by the compiler</desc>
                        <notes>If a reference to a location is made in a player command the output of it will be capitalized. Would it be better to have the interpreter do it? Probably not.
                            
                            One solution is to leave location names as they are. This forces the author to use quotation to get location names in edit case. And will have to use multiple names if a player is to refer to them.
                            
                            See regression/defaultSyntax1
                            
                            There is a solution suggested in compiler/prop.c/analyseName()</notes>
                    </task>
                </task>
                <task>
                    <desc>Embedded printout (definite form)</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Embedded printout (indefinite form)</desc>
                    <notes/>
                </task>
                <task>
                    <desc>String operators</desc>
                    <notes>concatenation
                        substring extraction
                        substring searching
                        
                        
                        &lt;s1&gt; + &lt;s2&gt;
                        Strip (First|Last) [&lt;n&gt;] (Word|Character) From &lt;s1&gt; [Into &lt;s2&gt;]</notes>
                    <task>
                        <desc>String concatenation</desc>
                        <notes>&lt;s1&gt; + &lt;s2&gt; as expression</notes>
                    </task>
                    <task>
                        <desc>Substring extraction</desc>
                        <notes>Strip (First|Last) [&lt;n&gt;] (Word|Character) From &lt;s1&gt; [Into &lt;s2&gt;]</notes>
                    </task>
                </task>
                <task>
                    <desc>Symbolic step and breakpoints</desc>
                    <notes>Implement a feature to make it possible to single step per source line.
                        
                        Design:
                        - a new instruction LINE &lt;no&gt;, &lt;file&gt;
                        - generate a list of source file names to index into
                        - for every statement and expression that is generated also generate a LINE instruction
                    </notes>
                </task>
                <task>
                    <desc>A LOCATE in an ENTERED causes interpreter loop if the actor is already there</desc>
                    <notes>Entered
                        Locate x Here.
                        
                        This clause should not be run if the actor x is already in the room.</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev29</desc>
                <notes/>
                <task>
                    <desc>Article handling</desc>
                    <notes>Need:
                        Instances are mentioned and described in a number of situations. Sometimes it is necessary to refer to it in an indefinite form and sometimes in a definite form. E.g
                        
                        I can't open &lt;indefinite form&gt;.
                        You can't take &lt;definite form&gt;.
                        
                        Analysis:
                        Maybe we need INDEFINITE &amp; DEFINITE forms but also PLURAL form and in the form "any xx". We could have sub clauses for ARTICLE,  PRONOUN an PLURAL
                        
                        Design:
                        The article Isa b
                        Definite
                        Article "the".
                        Pronoun "it".
                        Plural "articles"
                        Indefinite "any article"
                        
                        Design? If an instance has a Mentioned clause it should be used instead of any default always. Mentioned should be in undefinite form. How then do Articles apply?
                        
                        Not all languages have definite and indefinite articles that work well:
                        
                        Definite "den"
                        Indefinite "en"
                        Mentioned "stol"
                        
                        Perhaps:
                        
                        Name stol
                        Definite Form "stolen"
                        Indefinite Form "en stol"
                        Plural "stolar"??? Need plural definite AND indefinite???
                        
                        With corresponding:
                        Say o. : use Name =&gt; "stol"
                        Say The o. : use Definite =&gt; "stolen"
                        Say A o. : use Indefinite =&gt; "en stol"
                        Say Any o. : use Plural =&gt; "stolar"??? Not needed, use "I can't see any" Say o. "." for now.
                        
                        We could have Indefinite Form and Indefinite Article both not allow both in the same declaration. "Say The x ."would then use Definite Form if there is one or construct it from Definite Article + Mentioned. "Say A x." would then use Indefinite Form if available, or else Indefinite Article + Mentioned.
                        
                        Since Mentioned is constructed from the Name clause the following would work:
                        
                        Every person Isa actor
                        Definite Article ""
                        End Every person.
                        
                        The mr_a Isa person
                        Name mr 'Andersson'
                        Name mr andersson
                        End The mr_a
                        
                        Problem is still what to say when:
                        
                        &gt; talk to mr andersson
                        I can't see any mr andersson here.
                        
                        But the library could:
                        
                        Syntax talk_to = talk to (p)! Where p Isa person Else
                        
                        Add To Every person
                        Verb talk_to
                        Check p Is Here
                        Else "I can't see" Say The p. "here."
                        End Verb talk_to.
                        End Add To Every person.
                        
                        Verb talk_to 
                        
                        Do we really need all the four forms? Indefinite singular/plural and definite singular/plural?
                        
                        Possibly there is also a fifth form, as in "I can't see *any* door here." But let's leave that for later.</notes>
                    <task>
                        <desc>Definite and indefinite article declaration</desc>
                        <notes>If a definite and indefinite article declaration is introduced the following can be made possible:
                            
                            "You can not x" SAY A obj.
                            
                            "You open" SAY THE obj.
                        </notes>
                        <task>
                            <desc>Indefinite Article declaration</desc>
                            <notes>Rename it an document it.</notes>
                        </task>
                        <task>
                            <desc>Definite Article declaration</desc>
                            <notes>Implement and document.</notes>
                        </task>
                    </task>
                    <task>
                        <desc>Printing of articles</desc>
                        <notes>How do we use definite and indefinite articles in printouts?
                            
                            SAY the O.
                            
                            SAY an O.
                            
                        </notes>
                        <task>
                            <desc>SAY an/the &lt;param&gt;</desc>
                            <notes>A SAY should refer to which form of articles should be used:
                                
                                Say The x.  (embedded as $the x$?)
                                Say An x.
                                Say x.
                                
                                Possibly later:
                                Say Any x.
                                Say No x,
                                
                                Requires sections something like:
                                
                                Definite
                                Article "a".
                                
                                Indefinite
                                ""
                            </notes>
                            <task>
                                <desc>SAY An x.</desc>
                                <notes>New variant on the Say statement to use indefinite article. Implement it. Also change "Say x." to mean "Mention" (which it already should).</notes>
                            </task>
                            <task>
                                <desc>Say The x.</desc>
                                <notes>New variant of Say statement to use Definite article + mentioned.</notes>
                            </task>
                        </task>
                    </task>
                    <task>
                        <desc>Inheriting Definite and Indefinite articles</desc>
                        <notes/>
                        <task>
                            <desc>Inheriting Definite Articles</desc>
                            <notes/>
                        </task>
                        <task>
                            <desc>Inheriting Indefinite Articles</desc>
                            <notes/>
                        </task>
                    </task>
                </task>
                <task>
                    <desc>Pronoun synonyms in player input</desc>
                    <notes>Personal pronouns are nice if allowed in input. "Him", "her" could be default synonyms for "it".</notes>
                </task>
                <task>
                    <desc>Capitalizing of "proper_name" in library and doc</desc>
                    <notes>Steve mentioned that the library relies on v2 behaviour to automatically caps actor names.
                        
                        Implementation:
                        - Document new behaviour. (DONE)
                        - Fix library. (To Be Done)
                        
                        But proper_name is actually used to switch between using articles and names:
                        
                        If x Has proper_name Then
                        Say x. "looks at you."
                        Else
                        "The" Say x. "looks at you."
                        End If.
                        
                        This will not be required when definite and indefinite form printing is implemented.
                    </notes>
                </task>
                <task>
                    <desc>Containers can take any type of instance, how to handle Limits?</desc>
                    <notes>Problem: if we can put actors in containers how do we handle attributes that might only be available on objects.
                        
                        Step 1: prohibit containers to contain anything not an object? How?
                        What to do when an instance not an object is moved into the container?
                        
                        Implement the structures for "Takes &lt;class&gt; Else &lt;statement&gt;" and use them with default &lt;class&gt; = object and &lt;statements&gt; "You can't put that in there."
                    </notes>
                </task>
                <task>
                    <desc>Column calculation bugs</desc>
                    <notes>$t does not move to next tab pos.</notes>
                </task>
                <task>
                    <desc>"Describe this." Does not work.</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Multiple syntaxes for the same verb does not work for four</desc>
                    <notes>syntax x = a (x). x = b (x). x = c (x). x = d (x).
                        
                        Generates wrong syntax tables for b and c.</notes>
                </task>
                <task>
                    <desc>Double click on a .alan file makes WinAlan fail to find the file</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Declaration of indefinite and definite forms</desc>
                    <notes>The forms should override articles</notes>
                    <task>
                        <desc>Declaration of Indefinite Form</desc>
                        <notes>Indefinite Form "en stol"</notes>
                    </task>
                    <task>
                        <desc>Declaration of Definite Form</desc>
                        <notes>Definite Form "stolen"</notes>
                    </task>
                    <task>
                        <desc>Say An x. to use Indefinite Form clause if available.</desc>
                        <notes>Should use Indefinite Form if available, else Indefinite Article + "Say x."</notes>
                    </task>
                    <task>
                        <desc>Say The x. to use Definite Form if available.</desc>
                        <notes>Should use Definite form if available, else Definite Article + "Say x."</notes>
                    </task>
                    <task>
                        <desc>Inherit Definite/Indefinite Forms</desc>
                        <notes/>
                    </task>
                    <task>
                        <desc>Figure out the inheritance rules between forms and articles</desc>
                        <notes>The [in]definite will be investigated in this instance first and its implementation will rule. If no form or article is defined in the instance the parents will be investigated until one is found. If that is an article the instance will be mentioned, otherwise it is assumed that the parent will implement the full form.
                        </notes>
                    </task>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev28</desc>
                <notes/>
                <task>
                    <desc>Capitalization of nouns</desc>
                    <notes>Think about a way to allow nouns to be capitalized, either automatic but preferably by author choice. C.f. german. Language option dependent?
                        
                        design: Interpreter capitalizes last word in SAY routines, compiler generates this option for some languages.</notes>
                </task>
                <task>
                    <desc>Support for German</desc>
                    <notes>Initial version done. Will have to update when SAY forms are available.</notes>
                </task>
                <task>
                    <desc>Location ENTERED</desc>
                    <notes>The old DOES clause of locations is removed. Do we need it? If so it should be named ENTERED since it is more descriptive of what it means.
                        
                        ADVENT requires full implementation.</notes>
                </task>
                <task>
                    <desc>Converter should convert all statements in CAVE</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Converter should set current directory to source file</desc>
                    <notes>Description:
                        Otherwise the includes won't work currectly. This is only a problem when executing from WinGUI.</notes>
                </task>
                <task>
                    <desc>WinAlan</desc>
                    <notes>As it is impossible to use Windows app from the console and attach output to the console we will have to make a WinAlan.exe and an alan.exe
                        
                        It should also work from the desktop by double-clicking. Output should go in same directory.</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev27</desc>
                <notes/>
                <task>
                    <desc>WinArun's about box shows WINARUNVERSION instead of real version</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Update library w.r.t. discovered WHEN-problem multi param verbs</desc>
                    <notes>Cf. Steves new library files</notes>
                </task>
                <task>
                    <desc>Update Makefile to have dist for source</desc>
                    <notes/>
                </task>
                <task>
                    <desc>"Increase v Of this" not working</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Refactor gealtent to use Entry</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Scores was not initialised from loaded data</desc>
                    <notes>To avoid reversing twice, restart does not load the program, instead it only initialises the dynamic data areas. Scores was forgotten.</notes>
                </task>
                <task>
                    <desc>Bookkeep reversing procedure to avoid reversing same structure twice</desc>
                    <notes>Implementation: Strategy implemented, to be copied when needed. Only need to add it to every reverse procedure.
                        
                        It would be rather straight forward to book-keep all Aaddr:s that where reversed and avoid doing it a second time if the structure is such that multiple structures refered to the same substructure.
                        
                        It would only be necessary to bookkeep structures that require it. I.e. ones that now point to the same address from multiple places.
                        
                        This would allow code generating once for some inherited constructs:
                        -scripts
                        -descriptions
                    </notes>
                </task>
                <task>
                    <desc>Make interpreter automatically capitalize words after full stop</desc>
                    <notes>Currently might look "xyz. mr x ..." because you can not force NAME "Mr X" since that would be wrong in the common case ("You can not take Mr X.")</notes>
                </task>
                <task>
                    <desc>Prohibit declaration of a container class</desc>
                    <notes>You can not define a class "container" as that would shadow the built in handling of restrictions "Isa container".</notes>
                </task>
                <task>
                    <desc>Optimize generation of containers</desc>
                    <notes>We could (and already tried to) optimize the generation of container bodies by utilizing the fact that container bodies are reentrant and inherited bodies are pointed to from the instances.
                        
                        This however requires that the code for a container body is not reversed more than once. As it is now this can not be avoided.
                        
                        A prerequisite action would be to fix this multiple reversing problem.</notes>
                </task>
                <task>
                    <desc>Section in the manual to describe automatic formatting</desc>
                    <notes>Capitalization after full stop and paragraph.
                        No space before full stop.
                        $$ reset both auto-formattings.
                    </notes>
                </task>
                <task>
                    <desc>Automate building the Windows install</desc>
                    <notes>sed the VERSION into the Inno Script, and use it also to name the setup.exe</notes>
                </task>
                <task>
                    <desc>Opaque containers</desc>
                    <notes>Allow:
                        
                        The box Isa object
                        Opaque Container
                        Verb open
                        Does Make This open. Make This Not opaque.
                        Verb close
                        Does Make This closed. Make This opaque.
                        End The box.
                        
                        I.e. the container has a state which controls if contents of it is listed and reachable. That state can be set using the special attribute "opaque" which is only present in instances that are containers.
                        
                        Warn (in instances that are containers) for declaring them as they would hide the built-in attribute.</notes>
                </task>
                <task>
                    <desc>Parameters should be defined in syntax restrictions</desc>
                    <notes>This problem was discovered in give.i trying to do
                        
                        Where recip Isa container Else Say recip. "cant' carry anything."
                    </notes>
                </task>
                <task>
                    <desc>Converter program from 2.8 to 3.0</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Windows file selection dialogue for compiler</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: v2.8.7</desc>
                <notes/>
                <task>
                    <desc>Parser confusion in v2.8</desc>
                    <notes>From Lydia:
                        I'm implementing a direction-based movement system. So, for instance,
                        I need the verb "left", as well as the verb "turn left".
                        
                        The problem is, when "turn left" exists, ALAN ends up scrambling its
                        verb table, resulting in "left" become "quit".
                        
                        This does not seem to happen with exit directions; for instance, I
                        can have an exit "north" and "turn north" will not smash the verb
                        table.
                        
                        ANALYSIS:
                        
                        This is a problem when a word is declared as a verb, and later in the source also as a "preposition".
                    </notes>
                </task>
                <task>
                    <desc>$p, $n problem in new winarun</desc>
                    <notes>So sorry, but I have found a bug in the new ARUN for windows.
                        
                        Apparently $n (new line) and $p (paragraph, aka one empty line) are 
                        indistinguishable. All my $p codes are doing the function of $n, and not 
                        properly producing a blank line.
                    </notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev26</desc>
                <notes/>
                <task>
                    <desc>Show "imagefile"</desc>
                    <notes>Use glk_image_draw() in the text window. Align with imagealign_MarginLeft. Possibly add Show "imagefile" [Left|Right] to use also imagealign_MarginRight.
                        
                        Use glk_gestalt(gestalt_Graphics, 0) to verify if graphics is available.
                        
                        Add glk_window_flow_break before every glk_image_draw and before every newline() and para().
                        
                        PROBLEM: imagealign_MarginXXX is only allowed directly after a newline. Does it work to insert a newline before every SHOW?
                        
                        DESIGN: create a list of ID:s that collects alla graphics files. Before code generation:
                        - sort the files in alphabetic order
                        - number them and put that in the ID:s, same names get same ID:s
                        - copy the files to resource names (PICnn,ext)
                        Code generation then can pickup the resource numbers from the ID:s</notes>
                </task>
                <task>
                    <desc>Move current.verb code from "secret" place after class restriction table</desc>
                    <notes>Seems like the flags in the EOS syntax element could be used. Verify that it is not used for anything else.
                        
                        Remember to change the reverse routine.</notes>
                </task>
                <task>
                    <desc>COUNT &lt;right hand side&gt; {AND/OR &lt;right hand side&gt;} &lt;where&gt;</desc>
                    <notes>New right hand side of expression to augment COUNT aggregate.
                        
                        First step: DONE!
                        Allow for it in ACODE.
                        
                        push initial aggregate value (different for MIN &amp; MAX!!
                        AGRSTART:  push 1 (instance index), twice
                        &lt;rhs&gt;: code to eval right hand side and leave true or false
                        AGRCHECK: if pop() == false then find ENDAGR else continue
                        &lt;rhs&gt;: code to eval, leave true or false
                        AGRCHECK: d:o
                        COUNT: add 1 (or attribute) to element below stack top (aggregate value)
                        ENDAGR: if top() &lt;= instanceMax then push(pop()+1) and go to code after AGRSTART else pop() of instance index revealing aggregate value
                        
                        Second step:
                        Allow one right hand side. DONE!
                        
                        Third step:
                        Allow concatenated right hand sides. If no ISA use "Isa object" by default for compatibility reasons?? No. DONE!</notes>
                </task>
                <task>
                    <desc>Bug: 1 + 1 = 2 parses unnaturally, requires (1+1) </desc>
                    <notes/>
                </task>
                <task>
                    <desc>Verb declarations with multiple verbs</desc>
                    <notes>Possibly by introducing an intermediate level we could fix the problem with parameter references such as in
                        
                        give_to = give (obj) to (act)
                        give = give (act) (obj)
                        
                        verb give, give_to
                        make obj ...  -- obj is parameter #1 in give_to and #2 in give!!
                        
                        Also need to consider how to warn for the same verb declared without a parameter at global level and with a parameter. Is this the same as declaring it with two separate syntax declarations? No, if done so the compiler complains.
                        
                        DESIGN: Change to verb code in the syntax to a syntax code. Number all syntaxes. For each syntax connect it to a verb, Choose one syntax to represent the canonical parameter order. For each syntax create a table that maps the parameters to the canonical order.
                        
                        TASK: Introduce the syntax mapping table, first to map to the same order.
                        TASK: Map parameters through the mapping table
                        TASK: allow multiple syntaxes for same verb
                        TASK: create multiple entries for same verb in syntax mapping table
                    </notes>
                </task>
                <task>
                    <desc>Multiple but different syntaxes for same verb</desc>
                    <notes>
                        For multiple syntax verbs to be really useful it should be possible to use the parameters in different order in the syntaxes:
                        Syntax give_to_actor = give (thing) to (person)
                        Syntax give_actor = give (person) (thing)
                        Of course it would then also be handy, almost required, to be able to create "verb synonyms". Currently you would have to add them both to every verb definition. So this complexity is one reason why the "multiple syntax verb" feature has not received very much attention.
                        To implement multiple but different syntaxes for the same verb a mapping between parameter positions have to be made. E.g. in
                        
                        Verb give_to_actor, give_actor ...
                        
                        We will have to refer to either parameter 1 or 2 for a reference to thing depending on the syntax used. Some kind of mapping table could be used.
                    </notes>
                </task>
                <task>
                    <desc>Missing lines in -full listing</desc>
                    <notes>Messages with only informational messages are not shown if listing is filtered using severity
                        
                        e.g. alan -full inheritVerb1:
                        1.  Every x
                        2.    Isa object.
                        4.      Does Say c.
                        =====&gt;               1
                        
                        *1*   310 E : Identifier 'c' not defined.
                        
                        But  alan -full inheritVerb1 -info:
                        
                        1.  Every x
                        2.    Isa object.
                        3.    Verb v
                        =====&gt;         1
                        
                        *1*   231 I : No syntax defined for this verb, assumed 'v (object)'.
                        
                        4.      Does Say c.
                        =====&gt;               1
                        
                        *1*   310 E : Identifier 'c' not defined.</notes>
                </task>
                <task>
                    <desc>If a printout start with a "." don't print a space even if needsp is true</desc>
                    <notes>This will make most uses of $$ go away.
                        
                        E.g.
                        "The" Say x. "$$."</notes>
                </task>
                <task>
                    <desc>Default syntax with parameter</desc>
                    <notes>Does it work to refer to the default parameter "object"? Yes.
                        How about if it is an actor? No. Because the default syntax is "object Isa object" It should be "object Isa &lt;current class&gt;", but how do we know that?
                        
                        Is it possible to defer the actual class restriction to execution? Or should we look at the class which has the verb definition? What about if it is in an instance, look at its class? Yes. DONE.
                        
                        However, there is no possibility to have default restrictions work the same way since we have no idea in which classes the verb is defined. Remember that restrictions are declared together with the syntax which is declared once outside all entities.
                    </notes>
                </task>
                <task>
                    <desc>UNDO</desc>
                    <notes>Investigate the possibility to just reallocate new admin[] and instance[] tables after each turn and make undo backup.
                        
                        Ok, need to save event queue, instance and admin as well as score table, which needs to be copied in init(),
                        
                        Remember to handle last UNDO gracefully.
                        
                        Did not work since the attributes are in the original code. How can we extract them to the dynamic area? Or should be rethink the whole undo thing:
                        
                        Allocate one big dynamic area in which we copy instance, admin. Attribute areas are copied there for all instances and their new address noted in the instances...
                    </notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev25</desc>
                <notes/>
                <task>
                    <desc>Stop ACTOR</desc>
                    <notes>
                        To interupt an actors execution of a script you have to have an empty script and do:
                        
                        USE empty_script FOR actor.
                        
                        A separate statement would be better (INTERRUPT?)
                        
                        Another suggestion would be:
                        
                        STOP &lt;actor&gt;.
                        
                        E.g.
                        
                        stop Painter.
                    </notes>
                </task>
                <task>
                    <desc>Clause on containers for removing things/Actor clash</desc>
                    <notes>
                        Actor-clash handling, i.e. what happens when an object is removed from an actor? How to specify if this is possible and what the actor does? Possibly a new clause in containers:
                        
                        EXTRACT
                        CHECK monster Is sleeping
                        DOES Make monster Not sleeping.
                        
                    </notes>
                </task>
                <task>
                    <desc>Documentation is wrong about DEPENDING ON  syntax?</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Full listing on the screen misses lines</desc>
                    <notes>
                        Refer to compiler/testing/addVerb losing line 2</notes>
                </task>
                <task>
                    <desc>Add To Descriptions</desc>
                    <notes>Need to code generate separately until we bookkeep reversal addresses.</notes>
                </task>
                <task>
                    <desc>List This. does not work.</desc>
                    <notes>See regression/testing/listThis</notes>
                </task>
                <task>
                    <desc>About-box should show version info</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Warn for instances not inheriting from anything, especially the hero</desc>
                    <notes/>
                </task>
                <task>
                    <desc>SIGSEGV when unable to open output files</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Check that DEPENDING ON works as it should</desc>
                    <notes>Yup!</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev24</desc>
                <notes/>
                <task>
                    <desc>ISA expression</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Multiple restrictions for the same parameter</desc>
                    <notes>Must allow for gradual refinement of a parameter in a restriction:
                        
                        Where p Isa thing Else ...
                        And p Isa object Else ...
                        And p Isa movable_object Else ...
                        
                        Analysis should verify that later restrictions restrict to subclasses of the earlier.
                        
                        This also should be noted in the symbol-&gt;fields.parameter.class so that the most restrictive is used.
                        
                        Also check "Restrictions can only restrict to one class" in Strategies
                    </notes>
                </task>
                <task>
                    <desc>ACTOR might be a container</desc>
                    <notes>If
                        Add To Every Actor
                        Container
                        End Add To.
                        has been done an actor is a container which is not recognized by verifyContainer()
                        
                    </notes>
                </task>
                <task>
                    <desc>Add To Every xyz &lt;container&gt;</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Class names when debugging</desc>
                    <notes>Tracing should include class name where code is declared.
                        If not present in A3C class names must be available.
                    </notes>
                </task>
                <task>
                    <desc>Document semantic restrictions for entity, literal etc.</desc>
                    <notes>Sections 4.14?</notes>
                </task>
                <task>
                    <desc>Menu-entries for open, save, restart, restore, debug, transcript etc.</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev23</desc>
                <notes/>
                <task>
                    <desc>FOR EACH &lt;id&gt; ISA &lt;class&gt; DO ... &lt;id&gt;</desc>
                    <notes>Create a temporary structure in the symbol table
                        This structure should be refered to first to see if the identifier is there
                        
                        Requires:
                        Two new calls newFrame and killFrame
                        A Frame stack in the symbol table.
                        
                        DONE:
                        - Frame handling
                        - Local symbols
                        
                        TODO:
                        - Calculate levels below from frame level (how to remember frames during code generation?)
                        - Generate GET/SET-LOCAL from ID with symbols of LOCAL kind</notes>
                </task>
                <task>
                    <desc>Verb bodies should by default apply to all parameters</desc>
                    <notes>Default parameter for a WHEN-less verb body should be reset to 0 (meaning it will execute for all parameter places).
                        (It did not work to force a WHEN clause, this was not the common case).
                        Document this behaviour and point out that if a verb body gets executed more than once you should consider a WHEN clause on that verb.</notes>
                </task>
                <task>
                    <desc>Warn for verb bodies with no WHEN clauses if it has more than one parameter</desc>
                    <notes>Verbs in locations are represented by the parameter number -1, a no-when-clause body by 0, and others by their parameter number</notes>
                </task>
                <task>
                    <desc>Adding a Verb that is already present gives sub-optimal error message</desc>
                    <notes>Design:
                        Refactor out a function verbAlreadyDeclared() which takes an existing verb identifier and looks for it in a verb list.
                        This could be called from both analyzeVerbs() and addVerb().
                        
                        Requirement:
                        See exampe, a better message would be "Can not add because it is already defined for obj." Would require a loop like the one in property analysis, which could probably be refactored out.
                        
                        addVerb.alan
                        
                        1.  Every obj Isa object
                        3.    End Verb.
                        4.  End Every.
                        5.
                        6.  Add To Every obj
                        7.    Verb x Does "x/y"
                        =====&gt;         1
                        
                        *1*   220 W : Multiple definition of verb 'x' in this context.
                        
                        8.    End Verb.
                        9.  End Add.
                        10.
                        11.  The l Isa location
                        12.  End The l.
                        13.
                        14.  Start At l.
                        15.
                        
                        No detected errors.
                        1 warning(s).
                        1 informational message(s).</notes>
                </task>
                <task>
                    <desc>Document verb lookup, especially for alternatives and locations</desc>
                    <notes>Remember that a verb added to an entity will be inherite by both locations and things and will be executed for both the current location and the parameter(s)</notes>
                </task>
                <task>
                    <desc>Mentioned clause in location should override Name clause</desc>
                    <notes>Also warn for this.</notes>
                </task>
                <task>
                    <desc>Prohibit SAY for boolean attributes</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Warn for verbs added to entity</desc>
                    <notes>
                        .. since this is inherited by both locations and things. Probably they mean to put it on things.</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev22</desc>
                <notes/>
                <task>
                    <desc>Pre-defined classes literal, integer &amp; string</desc>
                    <notes>Need to have those class numbers also in the interpreter (ACODE.h)
                        
                        Parameters should refer to those classes so that they work as all other parameters.
                        
                        Remove isLit()?
                        
                        Document!</notes>
                </task>
                <task>
                    <desc>Remove keywords: integer, string</desc>
                    <notes>Requires syntax restrictions to handle those cases by using the built in classes instead.</notes>
                </task>
                <task>
                    <desc>"You can't instantiate from class 'integer'"</desc>
                    <notes>
                        Goes for literal, string &amp; literal</notes>
                </task>
                <task>
                    <desc>Entities are everywhere</desc>
                    <notes>Possibly things are restricted to only be present at a location, entities and locations are present everywhere but not show.
                        Interpreter should only display Things
                        
                        Make sure that the interpreter don't display them and document that.
                        
                        Document.</notes>
                </task>
                <task>
                    <desc>Can't add attributes etc. to literals</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Verb without alternatives should by default be 1?</desc>
                    <notes>
                        Maybe a verb body without a WHEN p should default to When #1.
                        Except when in a location.
                        
                        This could perhaps fix the problem with location verbs not working in a "global verbs without parameters" environment.</notes>
                </task>
                <task>
                    <desc>Update library to not use global verbs</desc>
                    <notes>Change library to use ADD TO ... VERB instead
                        Add test case to compile it.</notes>
                </task>
                <task>
                    <desc>Prohibit global verbs</desc>
                    <notes>Replace by verbs in appropriate class.
                        Document.</notes>
                </task>
                <task>
                    <desc>Instruction trace during IF</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Remove CVS operations in ok-regression script</desc>
                    <notes/>
                </task>
                <task>
                    <desc>For Every x Isa &lt;class&gt; Do xxx End For. (Class restriction)</desc>
                    <notes>
                        Add semantics to FOR EACH syntax (15)
                        Verify that the class identifier is a class. (10)
                        And loop only over those entities. (60)
                        
                        Code generate:
                        EACH 1
                        ISA 1, class
                        NOT
                        IF
                        NEXT
                        ...
                        ENDEACH
                    </notes>
                </task>
                <task>
                    <desc>Only sub-classes to actor may have scripts</desc>
                    <notes>
                        Verify and produce an error.</notes>
                </task>
                <task>
                    <desc>Warn for locations with container property</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev21</desc>
                <notes/>
                <task>
                    <desc>Try CHECKs in the complete inheritance tree</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Run Verb bodies in the complete inheritance tree also</desc>
                    <notes/>
                </task>
                <task>
                    <desc>ADD TO Verb</desc>
                    <notes>
                        Add verbs to classes
                        Just concat the new verbs to the class
                        
                        Unsuspend regression/save and regression/saviour
                        
                        
                        
                    </notes>
                </task>
                <task>
                    <desc>Global verbs should only be allowed without parameters</desc>
                    <notes>
                        and have the default syntax 'v' = 'v'
                        
                        Remove global verbs from the interpreter verb look up.
                        OK
                        
                        
                        Add a default syntax without parameters.
                        
                        
                        Rewrite documentation.
                        Add a conversion hint about global verbs -&gt; entity class.
                        
                        
                        Prohibit syntaxes with parameters for global verbs.
                        
                        
                        -----
                        
                        How do we handle the situation when the same verb is available globally and in instances/classes?
                        
                    </notes>
                </task>
                <task>
                    <desc>For Every x Isa &lt;class&gt; Do xxx End For. (code generation)</desc>
                    <notes>
                        No reference to the variable in this version. So syntax is
                        
                        For Every x Do ... End For.
                        
                        Analysis of contained statements.
                        
                        Code generate like this:
                        
                        BLOCK 1
                        SETLOCAL 0, 1, 1 /* Set local variable 1 in this block to 1 */
                        EACH 1 /* 1 is the local variable)
                        ...
                        ENDEACH
                        ENDBLOCK
                    </notes>
                </task>
                <task>
                    <desc>Locations should not be things?</desc>
                    <notes>
                        This would make it more natural to add attributes etc. to objects and actors.
                        
                        In particular verbs is tricky since you would probably not add the same verb to locations too:
                        
                        Add to every thing
                        Verb talk_to
                        ...
                        End Add.
                        
                        This would make every *location* have the talk_to verb and we don't really want that.
                        
                        So the predefined classes should have a top level class (entity) which thing and location inherits from. DONE!
                        
                        Document this!</notes>
                </task>
                <task>
                    <desc>THIS should be defined in classes</desc>
                    <notes>
                        It is!</notes>
                </task>
                <task>
                    <desc>List node type indicator</desc>
                    <notes>
                        A field in the list type that indicates list type.</notes>
                </task>
                <task>
                    <desc>Literal values in the interpreter</desc>
                    <notes>
                        litValues[lit-LITMIN] &amp; isLit()</notes>
                </task>
                <task>
                    <desc>Point to Slots from Symbol instead of having attribute lists</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Symbol kinds:</desc>
                    <notes>
                        What is a SYMBOL? Only id's that we need more info on, like
                        
                        CLASS, INSTANCE, VERB, PARAMETER (but not in symbol table)
                        
                        Not ATTRIBUTE, WORD (in dictionary), EVENT (not needed), SCRIPT
                    </notes>
                </task>
                <task>
                    <desc>What are names?</desc>
                    <notes>
                        And when to use them? Actors previously was default-described using:
                        
                        interpret(name);
                        msg(SEE_ACT1);
                        
                        Objects are now default-described by the mention-clause which is generated by the compiler.</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev20</desc>
                <notes/>
                <task>
                    <desc>Inherited verb bodies</desc>
                    <notes>
                        See "Execution of verbs at various places"
                        
                        But for now simply inherit the bodies and preserve any current quirks. Should we do this by replicating? Or by pointing to the same code in the classes? How do we then identify the verb body, they do not have unique identifiers...
                        
                        Generate the verbs in the classes and let the interpreter find the body in the same way as now (also looking up the class hierarchy).
                        
                    </notes>
                </task>
                <task>
                    <desc>Nested contexts</desc>
                    <notes>
                        It must be possible to nest contexts so that THIS can be looked up in a Verb context inside a Class or Instance context.
                        
                        Well, VERB_CONTEXT with a class != NULL is equivalent...
                        
                        But it is implemented now so...</notes>
                </task>
                <task>
                    <desc>Allow WHEN ... THEN ... END WHEN</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Inherited scripts</desc>
                    <notes>
                        If there are only inherited scripts for an instance we still have to generate the info to keep status. Is there really any such info or is that kept in the general status record?
                        
                        No it's in the admin record so we should be ok.</notes>
                </task>
                <task>
                    <desc>Current instance should change when executing verb bodies in parameters</desc>
                    <notes>
                        Verify this!</notes>
                </task>
                <task>
                    <desc>ADD should not allow overriding inheritance</desc>
                    <notes/>
                </task>
                <task>
                    <desc>For Every x Isa &lt;class&gt; Do xxx End For. (EVERY, ENDEVERY Acode part)</desc>
                    <notes>
                        New instructions:
                        
                        FOR n : increment LOCAL n, if bigger than number of instances skip to (and over) corresponding ENDFOR
                        
                        ENDFOR : skip backwards to corresponding FOR
                    </notes>
                </task>
                <task>
                    <desc>Refactor so that scripts are generated only once</desc>
                    <notes>
                        Currently they are simply copied in replicateScript() so that they are generated  once for every instance inheriting them.
                        
                        Instead all scripts should be generated in a common table, each script having its own unique id-code. (They could have the same name, since scripts are scoped within their containing class.)
                        
                        This implies collecting a scriptList during analysis, keeping only script references in instances and a global script table in the interpreter.</notes>
                </task>
                <task>
                    <desc>Refactor: All anxyz() -&gt; analyzeXyz()</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Refactor: All gexyz() -&gt; generateXyz()</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Verify that THIS works in Verb bodies</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev19</desc>
                <notes/>
                <task>
                    <desc>For Every x Isa &lt;class&gt; Do xxx End For. (BLOCK, LOCALS A-code part)</desc>
                    <notes>
                        To implement this we need a BLOCK, ENDBLOCK and a LOCAL instruction.
                        
                        The BLOCK instruction should take a number indicating how many words to allocate on the block locals stack for this block. The ENDBLOCK should pop that many from the locals stack.
                        
                        GETLOCAL &lt;l&gt;, &lt;n&gt; would get the local variable with index n in the current block if l==0 or l blocks down if it is not.
                        
                        It should be recursive in that each time a new block is entered the current block pointer is pushed and a new pointer allocated by pointing to a new "top" in the stack.
                        
                        This time around we use the normal stack, this means:
                        
                        BLOCK &lt;n&gt; : push the current BLOCKPOINTER, save the current stack pointer into the BLOCKPOINTER, push n words, 
                        
                        GETLOCAL &lt;l&gt;, &lt;n&gt; : access the n:th word above the current BLOCKPOINTER (bp+n) and push it. If l != 0 look l blocks down.
                        
                        BLOCKEND : restore stackpointer from BLOCKPOINTER, pop BLOCKPOINTER
                        
                        
                        
                    </notes>
                </task>
                <task>
                    <desc>Bug: attribute type mismatch refers to the current class</desc>
                    <notes>
                        Inherited attributes which override others with another type should refer to the original class instead of the current one. See compiler/testing/inheritedAttributeTypeError
                    </notes>
                </task>
                <task>
                    <desc>About Arun box in interpreter</desc>
                    <notes/>
                </task>
                <task>
                    <desc>bogus article re-declaration bug</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev18</desc>
                <notes/>
                <task>
                    <desc>DESCRIPTION CHECK/DOES</desc>
                    <notes>
                        By changing (or at least allowing) the description clause to
                        
                        Description
                        Check Location Is lit
                        Else "You can not see anything."
                        Does
                        "Some description..."
                        
                        We can finally crack the elusive darkness problem by defining:
                        
                        Every dark_location
                        Isa location
                        
                        Description
                        Check
                        
                        Remember that the Check and the Description should be inherited separately.
                        
                        The Checks should also be additive so that all checks in the inheritance chain must pass.</notes>
                </task>
                <task>
                    <desc>Refactor SLOTS to be PROPS</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev17</desc>
                <notes/>
                <task>
                    <desc>If a SAY refers to a parameter the print out should use the same words</desc>
                    <notes>
                        This is today done when "$o" is used, but should be implemented for SAY generally. So SAY must investigate if the instance was one of the parameters and if so use the words the player typed.</notes>
                </task>
                <task>
                    <desc>Class expression</desc>
                    <notes>
                        &lt;thing&gt; Isa &lt;class&gt;
                        
                        Will check if the item refered to as the &lt;thing&gt; belongs to &lt;class&gt; or a subclass to it.
                    </notes>
                </task>
                <task>
                    <desc>Document the THIS primary</desc>
                    <notes>
                        When and where it is applicable</notes>
                </task>
                <task>
                    <desc>Refactoring: find inherited description in the interpreter</desc>
                    <notes>
                        We must generate description for the classes!
                        
                        The classEntry need to be almost the same as the instanceEntry. This means that we can factor out the generation of common data. Semantic checks will have to prohibit use of non-class slots.
                        
                    </notes>
                </task>
                <task>
                    <desc>WinGlkArun should use the file open dialog if no parameter</desc>
                    <notes>
                        Argument handling in WinGlkArun seems a bit messy...</notes>
                </task>
                <task>
                    <desc>Describe the typical Alan "application" in the manual</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev16</desc>
                <notes/>
                <task>
                    <desc>Inherited DESCRIPTION</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Document classes in the tutorial part of the manual</desc>
                    <notes/>
                </task>
                <task>
                    <desc>ADD TO misses some attributes sometimes</desc>
                    <notes>
                        So I did a little more playing with a little test game. It might be that a
                        second "add to &lt;something&gt;" is not properly processed unless some other sort
                        of code has been compiled in the meantime. But I'm not sure I've worked out
                        the pattern yet. With the following game, I switched the order of the "add
                        to"s and changed "thing" to "object" a few times to try to follow it.
                        Hopefully you'll be able to work out what's going on.
                        
                        I tried compiling my test file with Alan 3.0.6, it displayed the same
                        behaviour as 3.0.15. So the problem has been around for a few versions.
                        
                        If you can't fix it yet but can discover a work-around then please let me
                        know. (One thing I've thought of, is that I could concatenate all the
                        scattered "add to's" for each class into one just so I can get a working
                        library for 3.0.15.)
                        
                        -------------------------------
                        add to every thing
                        is big.
                        end add to thing.
                        
                        --add to every thing
                        --is takeable.
                        --end add to thing.
                        
                        add to every object
                        is takeable.
                        end add to object.
                        
                        add to every object
                        is heavy.
                        is hard.
                        end add to object.
                        
                        verb take
                        does
                        if object is big then
                        "object is big"
                        end if.
                        if object is heavy then
                        "object is heavy"
                        end if.
                        if object is takeable then
                        "object is takeable"
                        end if.
                        if object is hard then
                        "object is hard"
                        end if.
                        end verb take.
                        
                        the aaa isa location
                        end the aaa.
                        
                        start at aaa.
                        
                    </notes>
                </task>
                <task>
                    <desc>LIMITS to use inherited attributes</desc>
                    <notes>
                        add to every thing
                        has
                        bulkiness 10.
                        end add to thing.
                        
                        
                        the jug isa object
                        container
                        limits
                        count 10 then
                        "Too much stuff"
                        bulkiness 50 then
                        "too heavy"
                        end the jug.
                        
                        the aaa isa location
                        end the aaa.
                        start at aaa.
                        
                        (From Steve G.)</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev15</desc>
                <notes/>
                <task>
                    <desc>Updated manual</desc>
                    <notes/>
                </task>
                <task>
                    <desc>WinGLK</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev14</desc>
                <notes/>
                <task>
                    <desc>Document Current Actor/Location</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Verbs in current location should be executed</desc>
                    <notes>
                        or shouldn't they? If so, exactly when?
                    </notes>
                </task>
                <task>
                    <desc>Verb alternatives</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Verb names must not be redefined</desc>
                    <notes>
                        In anvrbs() traversing is done to ensure this fix that wrt. ids</notes>
                </task>
                <task>
                    <desc>Text stored in the .ACD</desc>
                    <notes>
                        Instead of creating a separate .DAT file we could store the text in the end of the .ACD file and just add the .ACD size to every texts file position.
                        
                        Also changed extension to .A3C
                    </notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev13</desc>
                <notes/>
                <task>
                    <desc>Reference to attributes to class identifiers should be prohibited</desc>
                    <notes>
                        E.g.
                        
                        Every x
                        Is y.
                        ...
                        
                        ... If x Is y Then
                        
                        Should generate an error.
                        
                    </notes>
                </task>
                <task>
                    <desc>LOCATE AT Current Location</desc>
                    <notes/>
                </task>
                <task>
                    <desc>DESCRIBE statement</desc>
                    <notes>
                        To work with objects and actors.</notes>
                </task>
                <task>
                    <desc>atr Of Current actor</desc>
                    <notes>
                        In all references to attributes</notes>
                </task>
                <task>
                    <desc>atr Of Current location</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev12</desc>
                <notes/>
                <task>
                    <desc>Where HERE</desc>
                    <notes>
                        Refer to the current location.</notes>
                </task>
                <task>
                    <desc>HERE should also find things in containers that are not things (pure)</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Allow only names on scripts</desc>
                    <notes>
                        So that we can do a simple numbering scheme of them like with attributes when preparing for inheriting them.</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev11</desc>
                <notes/>
                <task>
                    <desc>Warn for instances and classes without inheritance</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Must be able to restrict to a class AND container</desc>
                    <notes>
                        It must be possible to use attributes for parameters restricted to a class and container:
                        
                        Syntax put_in = put (o) in (c)
                        Where c Isa x Else ...
                        And c Isa container ...
                        
                        Verb put_in
                        Does
                        Id c Is attr Then
                        List c.
                        
                        So the resolvation must be able to accept or return multiple restrictions. Probably by traversing all the restrictions for the parameter and verifying with them.
                        
                        This is the old "container actor" and "container object".</notes>
                </task>
                <task>
                    <desc>Execution of verb bodies in parameters</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev10</desc>
                <notes/>
                <task>
                    <desc>All actors should execute and rules should execute in between</desc>
                    <notes/>
                </task>
                <task>
                    <desc>What</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Remove objs &amp; acts in interpreter</desc>
                    <notes/>
                </task>
                <task>
                    <desc>anres() should be handed the VerbSymbol instead of the parameter list</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Bug: DEPENDING ON</desc>
                    <notes>
                        It should only execute the expression once. The current code generation and interpretation is wrong. Consider "DEPENDING ON RANDOM 1 TO 8".</notes>
                </task>
                <task>
                    <desc>SymNod -&gt; Symbol</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev9</desc>
                <notes/>
                <task>
                    <desc>Inherited container properties</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Saving and restoring</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Default syntax for verbs only in instance</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev8</desc>
                <notes/>
                <task>
                    <desc>Allow user defined classes in the restrictions</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Scripts to work</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Default container listing for actors</desc>
                    <notes/>
                </task>
                <task>
                    <desc>exp.class -&gt; expressionKind</desc>
                    <notes/>
                </task>
                <task>
                    <desc>NAME on location</desc>
                    <notes>
                        Should generate the "Mentioned"</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev7</desc>
                <notes/>
                <task>
                    <desc>Actors with attributes</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Events</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Debugger to handle instances and classes instead of objects et al.</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Bug: take all does not work</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Describe a present actor with default description</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev6</desc>
                <notes/>
                <task>
                    <desc>Bug: IT does not work in the interpreter</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Saviour</desc>
                    <notes>
                        Restructure to use classes instead of attributes.
                        But keep the attribute version for later.</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev5</desc>
                <notes/>
                <task>
                    <desc>Initial location could be in a container</desc>
                    <notes/>
                </task>
                <task>
                    <desc>LIST statement</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Container restrictions</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Container handling</desc>
                    <notes>
                        &lt;ITEM -- Not a proper class
                        &lt;STRING&gt;
                        &lt;NUMBER&gt;
                        &lt;THING
                        &lt;OBJECT&gt;
                        &lt;LOCATION&gt;
                        &lt;ACTOR&gt;&gt;&gt;
                        
                        
                        But where is CONTAINER? A suggestion is that it could be a property slot which is potentially available for all THINGs. But it will have to be activated much like today:
                        
                        Class box Isa Object
                        With Container
                        End Class box.
                        
                        This would imply that the Container slot is added to a node in the class hierarchy much like an attribute. It will also be inherited in the same way. Checks for EMPTY &amp; LIST etc. could then be done by checking that the class of the argument has the Container slot, explicitly or inherited.
                        
                        Note also that the Container slot can be added to a ENTITY declaration directly so there has to be a way to check:
                        
                        IF o ISA Container THEN ...
                        
                        or something similar.</notes>
                </task>
                <task>
                    <desc>Verb execution in instances</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev4</desc>
                <notes/>
                <task>
                    <desc>Reference to a parameter</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Parameters take precedence</desc>
                    <notes>
                        The execution environment passed along in analysis will indicate Verb/Syntax. A symbol table lookup should find these identifiers before e.g. classes and instances.
                    </notes>
                </task>
                <task>
                    <desc>Syntaxes with class restrictions</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Explicit syntax with parameter</desc>
                    <notes>
                        Define a verb and its syntax, then let expressions refer to the parameters in the syntax.</notes>
                </task>
                <task>
                    <desc>Default syntax</desc>
                    <notes>
                        Define a verb (but no syntax) and make a parameter refer to it.</notes>
                </task>
                <task>
                    <desc>NAMEs on an object</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Execution Environment</desc>
                    <notes>
                        Requires parameter lists, possibly in class or instance. Analysis should allow:
                        
                        - reference to LOCATION and OBJECT attributes for this class or instance (DESCRIPTIONs, EXITS, ...)
                        
                        - reference to parameters attributes (Verbs)</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev3</desc>
                <notes/>
                <task>
                    <desc>Syntaxes for simple verbs</desc>
                    <notes>
                        Like QUIT, LOOK.</notes>
                </task>
                <task>
                    <desc>Object references in player commands</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev2</desc>
                <notes/>
                <task>
                    <desc>MAKE statements</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Objects with attributes</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev1</desc>
                <notes/>
                <task>
                    <desc>Testing of attributes on locations</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Setting of attributes on location</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Testing of inherited attributes</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Setting of inherited attributes</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Semantic check of exits in not locations</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Inherited locations</desc>
                    <notes>
                        Traversing between instances inheriting from location more than one level.</notes>
                </task>
            </task>
            <task>
                <desc>Increment: version 3.0dev0</desc>
                <notes/>
                <task>
                    <desc>Moving from one location to another</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Objects at location NOT described if they have empty descriptions</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Objects at location described with own description</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Objects at location listed with own mentioned</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Objects at location described with default description</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Location described</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Location labeled</desc>
                    <notes/>
                </task>
                <task>
                    <desc>Start At</desc>
                    <notes/>
                </task>
            </task>
            <task>
                <desc>compiler/testing/sgcrash1 displays multiple "'box' not defined"</desc>
                <notes>This occurs at a initial location clause:
                    
                    The ... In box</notes>
            </task>
            <task>
                <desc>All instances not inheriting from anything should inherit directly from entity</desc>
                <notes>What is the problem with current strategy?
                    
                    Document it and make sure abilities are handled correctly. E.g. it should not be described, that is added by thing. What about presence?
                    
                    Or should we force inheritance clause? That would make it easier for a beginner not to forget to give the instance a class when they intend to. I strongly think YES!</notes>
            </task>
            <task>
                <desc>Restrictions can only restrict to one class</desc>
                <notes>It will not be possible to handle:
                    
                    Where o Isa object Or location ...
                    
                    Can only allow one class in a restriction.
                    
                    Affects anress() (no loop).</notes>
            </task>
            <task>
                <desc>Capitalized names is a problem in parameters since printing of them use player input (Step 2)</desc>
                <notes>E.g.
                    &gt; talk to mr x
                    
                    Does not output
                    
                    Mr X does not want to talk to you.
                    
                    This is because the 'x' is in the player input. This design was made so as to not reveal objects secret properties:
                    
                    &gt; examine rod
                    You can not examine the dynamite.
                    
                    Is it possible to do both? Current view is that a the feature with hiding names is an author responsibility. E.g he/she must program the mentioned clause to take care of this if required.
                    
                    Step 1: Don't ever use player input
                    
                    Step 2: Even better, but much harder would be to create default mentioned clauses by listing the word-numbers to show. (A words number would be the number of the lower case version of the word). Then a Say could select the words the player input but show them in the case the author wanted.</notes>
            </task>
            <task>
                <desc>change "*_x.h" to "*.x"?</desc>
                <notes>
                    No, since that would break *.[ch] convention.</notes>
            </task>
            <task>
                <desc>Font sensitivity (esp. proportional fonts)</desc>
                <notes>No. Leave this to a graphics layer such as GLK.</notes>
            </task>
            <task>
                <desc>Infinite loops can occur if the articles try to Say The this.</desc>
                <notes>There are a number of situations that can cause infinite interpreter loops. Like the recursive describe. Possibly they can be detected in the same way.
                </notes>
            </task>
            <task>
                <desc>Text formatting "statements"</desc>
                <notes>
                    $b for bold? Use ANSI? Or how about:
                    
                    $bold$
                    
                    $the x$
                    
                    Or HTML:
                    
                    this text is &lt;b&gt;bold&lt;/b&gt;
                    
                    Or XML-ish:
                    
                    this text is &lt;indent&gt;indented&lt;/indent&gt;</notes>
            </task>
            <task>
                <desc>InstanceAndVerb</desc>
                <notes>regression/pending/instanceAndVerb.alan
                    
                    syserr() because 'l' is both an instance and a verb.</notes>
            </task>
            <task>
                <desc>What to do about instances that are neither objects or actors?</desc>
                <notes>
                    Currently they are not described at all.</notes>
            </task>
            <task>
                <desc>Separate data and code</desc>
                <notes>Separate data and code in the .acd into two separate areas, point to them from the header. This way we could more easily do two things: run from disk (if memory is not large enough to hold both data and code) and implement undo (just save the data area before each command)</notes>
            </task>
            <task>
                <desc>SYNTAX ELSE parameter analysis</desc>
                <notes>
                    From a mail to SteveG:
                    The same goes for statements in the ELSE part of the WHERE clause in the SYNTAX declaration, and that is also how it is implemented (except it has some bugs). 
                    The problem is just that the assumption is false for exactly those statements. It is actually exactly the *complement* of what the types specified in the WHERE clause! 
                    E.g. in the example above the IF statement will be executed whenever the 'o' is *not* an OBJECT. So you can only allow operations legal for NUMBERS, STRINGS, ACTORS etc, actually everything NOT OBJECT.
                </notes>
            </task>
            <task>
                <desc>Bug: Syntax typing error</desc>
                <notes>
                    Thomas N:
                    paramatr() in atr.c
                    Statements in ELSE-part of a SYNTAX is really typed to the *complement* of the WHERE-part. I.e. the parameters can nearly always be STRINGS and NUMBERS which do not have attributes. This means that it is almost always impossible to refer to attributes in SYNTAX-ELSE clauses.
                    This must be handled by a new strategy for parameter class analysis. See "Parameter environment classing"
                    
                    SteveG: 
                    Secondly, I got an error about using an attribute in a CHECK's ELSE statement that said I couldn't do it because there was no guarantee that the entity wouldn't be a string or container in which case the attribute would not be defined. That error message was quite correct. However when I changed the CHECK to be more specific, I did not get the error message even though the entity might still be a string etc. The attached bad_attr.ala game demonstrates.
                </notes>
            </task>
            <task>
                <desc>When executing verbs in current location inherited verbs should be executed also</desc>
                <notes/>
            </task>
            <task>
                <desc>Allow lists of restriction classes and OR them together</desc>
                <notes>
                    Why? So not done.</notes>
            </task>
            <task>
                <desc>Include library in the release</desc>
                <notes/>
            </task>
            <task>
                <desc>AtrNod -&gt; Attribute</desc>
                <notes/>
            </task>
            <task>
                <desc>Do we need wht?</desc>
                <notes>
                    Yes. For WHAT_LOCATION, WHAT_SELF etc.</notes>
            </task>
            <task>
                <desc>Done flag in ExitEntry for reverse</desc>
                <notes>
                    Should be handle by separate bookkeeping in the reverse process instead.
                    
                    Or rather the ExitEntry need to be divided into an extra list, the direction lists.
                </notes>
            </task>
            <task>
                <desc>-dump 1234 to dump at various points in the process</desc>
                <notes/>
            </task>
            <task>
                <desc>ELM could be SYMs?</desc>
                <notes/>
            </task>
            <task>
                <desc>Entry types in acode.h</desc>
                <notes>
                    So that the compiler can create an entry and emit() the whole entry instead of relying on remembering the correct order and number of fields.
                    
                    Some done already.</notes>
            </task>
            <task>
                <desc>ID kinds</desc>
                <notes>
                    SYMBOL, WORD
                    
                    What is the difference between an ID and a symbol?
                    
                    Should there be any IDKINDS? How about having a SYMBOL pointer instead?</notes>
            </task>
        </task>
        <task>
            <desc>Misc</desc>
            <notes/>
            <task>
                <desc>Converter from 2.8 to 3.0</desc>
                <notes/>
            </task>
            <task>
                <desc>Compile Compiler on Metrowerks</desc>
                <notes>
                    Install Metrowerks
                </notes>
            </task>
            <task>
                <desc>Recover STEAM?</desc>
                <notes/>
            </task>
            <task>
                <desc>Regr</desc>
                <notes>
                    Could be a script which got:
                    
                    CASE = *.alan
                    COMMAND = alan $case | arun $case &lt; $case.input
                    
                    as parameters or .rc or some other configuration.</notes>
            </task>
            <task>
                <desc>Fix Toolmaker code generation problem</desc>
                <notes>
                    När man genererar kod tex alanCommon.h blir källpositionerna fel vilket gör det omöjligt att generera Alans parser mm. från källtexterna i CVS.
                    
                    Verkar bara gälla om man kompilerar med Cygwin och kör i ett Windows-shell</notes>
            </task>
            <task>
                <desc>SLOC counter for CVS</desc>
                <notes>
                    
                    Modified Lines::::::
                    Index: alan.c
                    ======================================================
                    RCS file: C:/Repository/alan/compiler/alan.c,v
                    retrieving revision 1.43
                    diff -r1.43 alan.c
                    522c522
                    &lt;     if (dbgflg)                       /* Force debugging */
                    ---
                    &gt;     if (debugOption)                  /* Force debugging */
                    
                    
                    Removed Lines:::::::::
                    
                    Index: testing/susp
                    ====================================================
                    RCS file: C:/Repository/alan/compiler/testing/susp,v
                    retrieving revision 1.1
                    diff -r1.1 susp
                    6d5
                    &lt;     cvs add $case.suspended 2&gt; /dev/null
                    
                    
                    Removed File:::::::::::::
                    cvs server: pre3/write.tst.expected was removed, no comparison available
                    
                    
                    Added File:::::::::::::::::
                    cvs server: write.input is a new entry, no comparison available</notes>
            </task>
        </task>
    </task>
</tasktracker>

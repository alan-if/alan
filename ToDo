ToDo:

	* Document how to produce a SCRIPT-file

	* MAC (or general?): allow .ACD/.DAT as well as .acd/.dat

	* The character set used by the compiler (when reading the
	source code) ought to be configurable through an option

		Option
		 Charset ISO/DOS/MAC.

	* Investigate the possibility to allow:

		> TAKE ALL green chairs

	This implies 1) a notion of plural nouns (in english generally
	's' and 2) new built in multiple reference algorithm. First
	point could be avoided if replaced by

		> TAKE EVERY green chair
		> PUSH EVERY button

	* ISA ACTOR ought to be available already before the class mechanism

	* is/are, have/has singular/plural in the documentation

	* Attribute that are entity types. Probably this ties in with
	the classing mechanism in that a reference can only be changed
	to something a sub class of what it was initially set to.

	* The 3.0 beta things:
		EVERY x <class declaration>
		THE y ISA x ...
		THING, OBJECT, LOCATION, ACTOR, CONTAINER predefined.

	which implies a more general "entity" type particularly in the
	interpreter.

	* EMPTY location where, or possibly LOCATE ALL <condition>
	<where> (This was prompted by the darkness and light example,
	the problem being that objects at the location are described
	by the implicit LOOK performed when locating the hero there)

	* Extend <what> to be also

		"ALL" [ <condition> { "AND" <condition> } ]

	which would allow:

		LOCATE ALL HERE AT cave.
		MAKE ALL OBJECT WITH size > 3 heavy.
		SET state OF ALL creature HERE AND IS hungry TO 0.

	* Describe the typical Alan "application" in the manual

	* Allow lists of right hand expressions in the DEPENDING ON
	case clauses:

		DEPENDING ON x
		=1, =3 : ...

	* Allow ISA DIRECTION in syntax restrictions? OK, how do we
	then perform the natural

		SYNTAX go = go (d) WHERE d ISA DIRECTION?

	* Experiment with making unknown words into strings:

		say hello to the guard => say "hello" to the guard

	if "hello" is an unknown word

	* Break out the main program from the interpreter so that it
	becomes easier to build windowed versions. This implies also a
	new "API" with functions like put_string(),
	calculate_length(), space_left() etc...

	* Nested locations? Check how TADS and Inform does locations
	within locations.

	* Check out the MaxZip and MaxTADS guy. Possibly that
	framework would be used for Arun on the Mac, MaxArun.

	* Think about punctuation ('.') in the language! Can it be
        made more optional?

	* Checks on containers to augment limits.

	* New clause in containers to use when extracting something
	out of the container.

	* Actor-clash handling, i.e. what happens when an object is
	removed from an actor? How to specify if this is possible and what
	the actor does?

	* Vehicles?

	* Multiclass word problem 1: The VERBDIR problem (check
	regression test verbdir), using the same word as both a verb
	and a direction does not work.

	* Multiclass word problem2: ADJECTIVE & VERB, doesn't work because
	the dictionary handling in the compiler (newwrd) returns the
        code of the found word which is the same as the adjective,
        resulting in execution of the wrong (if any) verb... (See
        regression test adjverb) Somehow we must separate word codes
        from the codes used by the objects, verbs etc.

	* Words can't be prepositions and verbs at the same time. See gestx()

	* New and better dictionary handling in the compiler could remedy
	the multiple word class problems

	* The conversion programs does not work on little-endians like
	PCs since the words are then written out in native format.

	* Think about a way to allow nouns to be capitalized, either
	automatic but preferably by author choice. C.f. german.

	* Confirm handling was trashed in 2.7. Any input is considered as
	non-affirmative. Need to change this so that a '(y)' can be used
	and input as affirmative.

	* Actor conversation al a INFOCOM "floyd, get the card"

	* Procedures!

	* Listing of saved games

	* Font sensitivity (esp. proportional fonts)

	* METAVERB, takes no tick

	* Potential problem: non-ISO sorting of dictionary

	* Verify $<n> w.r.t the syntax parameters

	* How to handle darkness and other global requirements on e.g. the
	location descriptions? This could possibly be handled by
	aspects of the descriptions, e.g. VISUAL DESCRIPTION, AUDIAL
	DESCRIPTION. These could be turned on/off using something like
	VISUAL ON. This would do away with the ever present test in
	the descriptions of dark locations.

	* SCHEDULE <event> <where> WHEN <expr>.

	* ASK, CONFIRM statement?

	* SCENERY word, word, word.

	* BACKGROUND to display a background picture (where appropriate),
	I like the Zork Zero thing...

	* PLAY statement, to play sounds (for how long?)

	* SHOW statement, to show a picture (how to place it?)

	* SYNTAX look_up = 'look' 'up' (str) ['in' (lexikon)],
	i.e. optional parts of a syntax which can be given default parameters

	* EXIT ELSE ...

	* Status Line

	* EXIT out TO RETURN ....

	* Check for 'locate hero'/'look' in DESCRIPTIONS (to prohibit
	"recursive look")

	* Replace printout of string attributes? Shouldn't they be
	surrounded by qoutes, as they are not indended as part of the
	descriptions but an attribute of an object, like the text written
	on a card.

	* SCORE & MAXSCORE as variables

	* > THE BALL, What do you want to do with the ball?, > KICK IT

	* the UNLESS? qualifier would be handy for creating libraries
	(and possibly otherwise too). The semantics would be that the
	verb body would be executed only if no other body was
	found. However this can nearly always be achieved by using
	ONLY where appropriate.

	* Conversion between 2.6 and 2.7 games (Not really needed)



DONE:

	* hints on cwsdpmi (as per Stephen Griffiths mail)

	* Publish the proposed library on the web pages.

	* List available games on the home page.

	* RANDOM should allow expressions

	* SCHEDULE does not allow integer expressions. Really should!

	* Document how to do darkness and light sources

	* Document the DEPENDING ON statement

	* Add IN to the identifier/reserved word set

	* DEPENDING ON e1: e2 {, en}: stmts ELSE stmts END DEPENDING.

	* Document that the inventory is actually the container of the
	hero (when that is true), and that the hero is a container
	actor.

	* Make the HERO a container actor with the inventory as the
	container if possible.

	* Describe the listing and error messages format better
	(positions, pointers etc.)

	* Document the e1 CONTAINS e2 - substring check

	* Document the BETWEEN statement

	* e1 BETWEEN e1 AND e3

	* More flexiblity in order of clauses, should be possible to
	be almost completely free.

	* Short-circuiting expressions, is it necessary? Can it be done?
		Well no, since it is a postfix machine, if we did that
		we would need to look forward to see if there is a
		logical operation after this expression, which implies
		that we still need to interpret (without evaluating)

	* Document how to create floating objects.

	* The "plant pot plant in plant pot" problem

	* Number registrations!

	* Named scripts: SCRIPT <id>, USE <id> FOR actor

	* MESSAGE : STATEMENTS

	* Change QUIT message to "Really quit (n) ?"

	* QUIT-hanteringen

	* Presence check after syntax check?

	* If the HERO is redefined mulitple times it does not work well.

	* Clean up the manual with respect to the MESSAGE-descriptions

	* Listing containers in the debugger

	* Change the interpreter to only look at its own name if no
	parameter was given.

	* Fix the lerchj attribute bug (regression/oatrs)


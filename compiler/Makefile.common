# Generic make rules for alan compiler
# Set:
#	COMPILER : which command to run the C compiler
#	LINKER : which command to run the linker
#	OSFLAGS : what flags must be passed to both compiler and linker
#	EXTRA_COMPILER_FLAGS : what extra flags to pass to the compiler
#	EXTRA_LINKER_FLAGS : what extra flags to pass to the linker
#
# You can:
#     make
#     make unit
#     make unitbuild
#     make linked_unittests_build
#     make isolated_unittests_build
#     make test
#     make coverage
#     make coverage_build
#     make coverage_report

ifneq ($(BUILDNUMBER),)
  # For snapshots we use buildnumber for version info and filenames
  BUILDVERSION = -$(BUILDNUMBER)
endif

CC = $(COMPILER)
CFLAGS = -I../interpreter $(COMPILEFLAGS) $(EXTRA_COMPILER_FLAGS) -DBUILD=$(BUILDNUMBER) $(OSFLAGS)

LINK = $(LINKER)
LINKFLAGS = $(OSFLAGS) $(EXTRA_LINKER_FLAGS)

gprof: EXTRA_COMPILER_FLAGS = -pg
gprof: EXTRA_LINKER_FLAGS = -pg

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
# Main target to do everything
#
.PHONY: all
all: unit build

# Target to just build
.PHONY: build gprof
build gprof: alan $(EXTRA_TARGETS)

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
# Run all tests!
#
UNITOUTPUT ?= -c
SOEXTENSION ?= so

.PHONY: test
test:
	@jregr -dir testing $(JREGROUTPUT)
	@jregr -dir testing/positions $(JREGROUTPUT)
	@jregr -dir testing/dump $(JREGROUTPUT)
	@jregr -dir testing/arguments $(JREGROUTPUT)
	@cd ../regression/platforms; cp platforms.alan $(OS).alan; ../../bin/alan $(OS); rm $(OS).alan
	@jregr -dir ../regression/platforms $(JREGROUTPUT)
# TODO: Since older interpreters barf on the tests for backwards compatibility of the compiler
# TODO: we need to split that up somehow
#	@cd ..;java -jar bin/jregr.jar -bin bin -dir regression/versions/compiler $(JREGROUTPUT)

# Clean
.PHONY: clean
clean:
	@-rm -rf *.$(SOEXTENSION) .*/*.o .*/*.d .*/*.$(SOEXTENSION) .*/*.gcno .*/*.gcda alan.res ../bin/alan ../bin/winalan .unittests .alan

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
# Alan command line compiler
#
ALANOBJDIR = .alan
ALANOBJECTS = $(addprefix $(ALANOBJDIR)/,${ALANSRCS:.c=.o}) $(ALANOBJDIR)/alan.version.o
-include $(ALANOBJECTS:.o=.d)
$(ALANOBJECTS): $(ALANOBJDIR)/%.o: %.c
	$(CC) $(CFLAGS) -MMD -o $@ -c $<

alan: $(ALANOBJECTS)
	$(LINK) -o alan $(ALANOBJECTS) $(LINKFLAGS)
	-@if ! test -d ../bin; then mkdir ../bin 2> /dev/null ; fi
	cp alan ../bin/alan

$(ALANOBJECTS): | $(ALANOBJDIR)
$(ALANOBJDIR):
	@mkdir $(ALANOBJDIR)

#################################################################
# Unit testing
#
# Two types:
.PHONY: unit
ifneq ($(CGREEN),yes)
unit:
	echo "No unit tests run, cgreen not available"
else
.PHONY: unit
unit: linked_unittests isolated_unittests
.PHONY: unitbuild
unitbuild: linked_unittests_build isolated_unittests_build
endif

CGREENLINKLIB ?= -lcgreen

UNITTESTSOBJDIR = .unittests
UNITTESTSOBJECTS = $(addprefix $(UNITTESTSOBJDIR)/,${UNITTESTSSRCS:.c=.o}) $(UNITTESTSOBJDIR)/alan.version.o
UNITTESTSDLLOBJECTS = $(addprefix $(UNITTESTSOBJDIR)/,${UNITTESTSDLLSRCS:.c=.o}) $(UNITTESTSOBJDIR)/alan.version.o

# Dependencies, if they don't exist yet
-include $(UNITTESTSOBJECTS:.o=.d)

$(UNITTESTSOBJDIR)/%.o: | $(UNITTESTSOBJDIR)

# Rule to compile unittest objects to subdirectory
$(UNITTESTSOBJDIR)/%.o: %.c
	$(CC) $(CFLAGS) -MMD -o $@ -c $<
$(UNITTESTSOBJDIR)/%_tests.o: %_tests.c
	$(CC) $(CFLAGS) -MMD -o $@ -c $<

# Create directory if it doesn't exist
$(UNITTESTSOBJECTS): | $(UNITTESTSOBJDIR)
$(UNITTESTSOBJDIR):
	@mkdir $(UNITTESTSOBJDIR)

###################################################################
# Build a DLL of all unittests in a separate dir that should exist...
linked_unittests_build: unittests.$(SOEXTENSION)

unittests.$(SOEXTENSION): CFLAGS += $(CGREENINCLUDE)
unittests.$(SOEXTENSION): LIBS = $(CGREENLINKLIB)
unittests.$(SOEXTENSION): $(UNITTESTSOBJECTS)
	$(LINK) -shared -o $@ $(UNITTESTSDLLOBJECTS) $(LINKFLAGS) $(LIBS)

# ... that can be run with the cgreen runner
linked_unittests: unittests.$(SOEXTENSION)
	$(CGREENLIBLOAD) $(CGREENBINDIR)cgreen-runner ./$^ --suite compiler_unit_tests $(UNITOUTPUT)

.PRECIOUS: .unittests/%_tests.o .unittests/%.o .unittests/%.$(SOEXTENSION) .unittests/%_tests.$(SOEXTENSION) .alan/%.o

#####################################################################
# Build a runnable DLL for each module where it can be tested in total
# isolation (with everything else mocked away, except lists.c and
# memory.c)

-include $(addprefix $(UNITTESTSOBJDIR)/,$(patsubst %,%.d,$(MODULES_WITH_ISOLATED_UNITTESTS)))
-include $(addprefix $(UNITTESTSOBJDIR)/,$(patsubst %,%_tests.d,$(MODULES_WITH_ISOLATED_UNITTESTS)))

ISOLATED_UNITTESTS_EXTRA_MODULES = util options sysdep lst dump opt type alan.version
ISOLATED_UNITTESTS_EXTRA_OBJS = $(addprefix $(UNITTESTSOBJDIR)/, $(addsuffix .o, $(ISOLATED_UNITTESTS_EXTRA_MODULES)))

# A test .$(SOEXTENSION) for a module is built from its .o and the _test.o (and some extras)
$(UNITTESTSOBJDIR)/%_tests.$(SOEXTENSION): $(UNITTESTSOBJDIR)/%.o $(UNITTESTSOBJDIR)/%_tests.o
	$(LINK) -shared -o $@ $(sort $(ISOLATED_UNITTESTS_EXTRA_OBJS) $^) $(LINKFLAGS) $(LIBS)

ISOLATED_UNITTESTS_DLLS = $(addprefix $(UNITTESTSOBJDIR)/,$(patsubst %,%_tests.$(SOEXTENSION),$(MODULES_WITH_ISOLATED_UNITTESTS)))

.PHONY: isolated_unittests_build
isolated_unittests_build: | $(UNITTESTSOBJDIR)
isolated_unittests_build: CFLAGS += $(CGREENINCLUDE)
isolated_unittests_build: LIBS = $(CGREENLINKLIB)
isolated_unittests_build: $(ISOLATED_UNITTESTS_EXTRA_OBJS) $(ISOLATED_UNITTESTS_DLLS)

.PHONY: isolated_unittests
# Then run all _tests.$(SOEXTENSION)'s with the cgreen-runner
isolated_unittests: CFLAGS += $(CGREENINCLUDE)
isolated_unittests: LIBS = $(CGREENLINKLIB)
isolated_unittests: isolated_unittests_build
	$(CGREENLIBLOAD) $(CGREENBINDIR)cgreen-runner $$f --suite Compiler $(UNITOUTPUT) $(ISOLATED_UNITTESTS_DLLS)


############################################
# Coverage
#
#   make coverage - rebuilds everything for coverage, runs all tests,
#                   generates and opens report
#   make coverage_build - builds what has changed for coverage
#   make coverage_report - generates the report

coverage coverage_build: EXTRA_COMPILER_FLAGS += --coverage
coverage coverage_build: EXTRA_LINKER_FLAGS += --coverage

coverage: clean coverage_build unit test coverage_report
	open coverage/index.html

coverage_build: build unitbuild
	@echo "***********************************"
	@echo "Run your tests and then 'make coverage_report'"

coverage_report:
	lcov --capture --directory . -b . --output-file coverage_tmp.info
	lcov --extract coverage_tmp.info '*.c' -o coverage.info
	genhtml coverage.info --output coverage

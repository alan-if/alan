#include "exp_x.h"
#include <cgreen/mocks.h>

int isSpace(unsigned int c) { 
  return (int) mock(c);
}

int isLower(unsigned int c) { 
  return (int) mock(c);
}

int isUpper(unsigned int c) { 
  return (int) mock(c);
}

int isLetter(unsigned int c) { 
  return (int) mock(c);
}

int toLower(unsigned int c) { 
  return (int) mock(c);
}

int toUpper(unsigned int c) { 
  return (int) mock(c);
}

char *strlow(char str[]) { 
  return (char *) mock(str);
}

char *strupp(char str[]) { 
  return (char *) mock(str);
}

int isISOLetter(int c) { 
  return (int) mock(c);
}

char IsoToLowerCase(int c) { 
  return (char) mock(c);
}

char IsoToUpperCase(int c) { 
  return (char) mock(c);
}

char *stringLower(char str[]) { 
  return (char *) mock(str);
}

char *stringUpper(char str[]) { 
  return (char *) mock(str);
}

int compareStrings(char str1[], char str2[]) { 
  return (int) mock(str1, str2);
}

void toIso(char copy[], char original[], int charset) { 
  mock(copy, original, charset);
}

void fromIso(char copy[], char original[]) { 
  mock(copy, original);
}

void toNative(char copy[], char original[], int charset) { 
  mock(copy, original, charset);
}

int littleEndian(void) { 
  return (int) mock();
}

char *baseNameStart(char *fullPathName) { 
  return (char *) mock(fullPathName);
}

void compile(void) { 
  mock();
}

Event *newEvent(Srcp *srcp, Id *id, List *stms) { 
  return (Event *) mock(srcp, id, stms);
}

void analyzeEvents(void) { 
  mock();
}

Aaddr generateEvents(ACodeHeader *header) { 
  return (Aaddr) mock(header);
}

void dumpEvent(Event *evt) { 
  mock(evt);
}

Expression *newAttributeExpression(Srcp srcp, Id *attribute, Bool not, Expression *ofWhat) { 
  return (Expression *) mock(srcp, attribute, not, ofWhat);
}

Expression *newBinaryExpression(Srcp srcp, Expression *left, Bool not, OperatorKind operator, Expression *right) { 
  return (Expression *) mock(srcp, left, not, operator, right);
}

Expression *newBetweenExpression(Srcp srcp, Expression *exp, Bool not, Expression *low, Expression *high) { 
  return (Expression *) mock(srcp, exp, not, low, high);
}

Expression *newStringExpression(Srcp srcp, long fpos, int len) { 
  return (Expression *) mock(srcp, fpos, len);
}

Expression *newSetExpression(Srcp srcp, List *set) { 
  return (Expression *) mock(srcp, set);
}

Expression *newScoreExpression(Srcp srcp) { 
  return (Expression *) mock(srcp);
}

Expression *newIntegerExpression(Srcp srcp, int value) { 
  return (Expression *) mock(srcp, value);
}

Expression *newIsaExpression(Srcp srcp, Expression *what, Bool not, Id *class) { 
  return (Expression *) mock(srcp, what, not, class);
}

Expression *newWhatExpression(Srcp srcp, What *what) { 
  return (Expression *) mock(srcp, what);
}

Expression *newWhereExpression(Srcp srcp, Expression *what, Bool not, Where *where) { 
  return (Expression *) mock(srcp, what, not, where);
}

Expression *newAggregateExpression(Srcp srcp, AggregateKind kind, Id *attribute, List *filters) { 
  return (Expression *) mock(srcp, kind, attribute, filters);
}

Expression *newRandomRangeExpression(Srcp srcp, Expression *from, Expression *to) { 
  return (Expression *) mock(srcp, from, to);
}

Expression *newRandomInExpression(Srcp srcp, Expression *what, Transitivity transitivity) { 
  return (Expression *) mock(srcp, what, transitivity);
}

void symbolizeExpression(Expression *exp) { 
  mock(exp);
}

void analyzeExpression(Expression *exp, Context *context) { 
  mock(exp, context);
}

Bool analyzeFilterExpressions(char *message, List *filters, Context *context, Symbol **foundClass) { 
  return (Bool) mock(message, filters, context, foundClass);
}

Bool isConstantIdentifier(Id *id) { 
  return (Bool) mock(id);
}

Bool isConstantExpression(Expression *exp) { 
  return (Bool) mock(exp);
}

Symbol *containerContent(Expression *what, Transitivity transitivity, Context *context) { 
  return (Symbol *) mock(what, transitivity, context);
}

Bool verifyContainerExpression(Expression *what, Context *context, char referer[]) { 
  return (Bool) mock(what, context, referer);
}

Symbol *symbolOfExpression(Expression *exp, Context *context) { 
  return (Symbol *) mock(exp, context);
}

void generateExpression(Expression *exp) { 
  mock(exp);
}

void generateFilter(Expression *exp) { 
  mock(exp);
}

void generateBinaryOperator(Expression *exp) { 
  mock(exp);
}

void generateLvalue(Expression *exp) { 
  mock(exp);
}

void generateAttributeReference(Expression *exp) { 
  mock(exp);
}

void generateAttributeAccess(Expression *exp) { 
  mock(exp);
}

void generateBetweenCheck(Expression *exp) { 
  mock(exp);
}

void dumpExpression(Expression *exp) { 
  mock(exp);
}


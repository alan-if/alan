/*----------------------------------------------------------------------*\
  sysdep.c

  This file contains necessary system dependent routines.

  Notes on string handling:

  - Native - means the "natural" character set/encoding for the
    platform, nowadays often UTF-8, but that was not the case in the
    beginning.

  - Internal - is always ISO8859-1 in which encoding everything
    internal should use (even dictionary entries, which is not certain
    it does currently. TODO!

  - Current - the compiler (currently) has options for different
    charsets, if that is used all input files are considered to be in
    that encoding, which might be different from the native encoding.
    It (will) also auto-detect an UTF BOM and enforce UTF-8 for that
    single file, which again might be different from native or the one
    given using the -charset option.

\*----------------------------------------------------------------------*/

#include "sysdep.h"

#include <time.h>


extern void syserr(char str[]);


/* The following work on ISO characters */

int isUpperCase(unsigned int c)          /* IN - ISO character to test */
{
  static char uppChrs[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337";
  int i;
  for (i = 0; i < strlen(uppChrs); i++)
    if (uppChrs[i] == c) return 1;
  return 0;
}


char IsoToLowerCase(int c)         /* IN - ISO character to convert */
{
  return (isUpperCase(c)? c + ('a' - 'A'): c);
}


/*----------------------------------------------------------------------*/
/* Case insensitive string comparison on internal strings */
int compareStrings(char *str1, char *str2)
{
  char *s1 = str1, *s2 = str2;

  while (*s1 != '\0' && *s2 != '\0') {
    if (IsoToLowerCase(*s1) < IsoToLowerCase(*s2)) return -1;
    if (IsoToLowerCase(*s1) > IsoToLowerCase(*s2)) return 1;
    s1++;
    s2++;
  }
  return IsoToLowerCase(*s2) - IsoToLowerCase(*s1);
}



/*----------------------------------------------------------------------
  toIso

  Converts the incoming string to ISO character set. The original is
  in the current character set which in the case of the compiler might
  be other than the native.

  */
void toIso(char copy[],         /* OUT - Mapped string */
           char original[],     /* IN - string to convert */
           CharSet charset)		/* IN - the current character set */
{
static unsigned char dosMap[256]
= {
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0A,0x0E,0x0F,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,
0xC7,0xFC,0xE9,0xE2,0xE4,0xE0,0xE5,0xE7,0xEA,0xEB,0xE8,0xEF,0xEE,0xEC,0xC4,0xC5,
0xC9,0xE6,0xC6,0xF4,0xF6,0xF2,0xFB,0xF9,0xFF,0xD6,0xDC,0xA2,0xA3,0xA5,0xDE,0xA6,
0xE1,0xED,0xF3,0xFA,0xF1,0xD1,0xAA,0xBA,0xBF,0xC0,0xC1,0xBD,0xBC,0xCF,0xAB,0xBB,
0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,
0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,
0xA1,0xA7,0xAD,0xB3,0xB8,0xB9,0xC3,0xCE,0xD2,0xD3,0xDB,0xDD,0xE3,0xF5,0xF8,0xFD,
0xA9,0xDF,0xC8,0xB6,0xCA,0xA4,0xB5,0xAE,0xD5,0xD0,0xD4,0xF0,0xD7,0xD8,0xCB,0xC2,
0xBE,0xB1,0xD9,0xDA,0xCD,0xCC,0xF7,0xA8,0xB0,0xB7,0xAF,0xAC,0xFE,0xB2,0xB4,0xA0};
  unsigned char *o, *c;

  switch (charset) {
  case CHARSET_ISO:
  case CHARSET_UTF8:
    if (copy != original)
      (void)strcpy(copy, original);
    break;
  case CHARSET_DOS:
    for (o = (unsigned char *)original, c = (unsigned char *)copy; *o; o++, c++)
      *c = dosMap[*o];
    *c = '\0';
    break;
  }
}


/*======================================================================*/
int littleEndian() {
  int x = 1;
  return (*(char *)&x == 1);
}


/*======================================================================*/
char *baseNameStart(char *fullPathName) {
  static char *delimiters = "\\>]/:";
  int i;

  for (i = strlen(fullPathName)-1; i > 0; i--)
    if (strchr(delimiters, fullPathName[i]) != NULL)
      return &fullPathName[i+1];
  return(fullPathName);
}
